<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cmake指令大全纯享版</title>
      <link href="/2024/03/01/Cmake%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8%E7%BA%AF%E4%BA%AB%E7%89%88/"/>
      <url>/2024/03/01/Cmake%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8%E7%BA%AF%E4%BA%AB%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-MinGW-CMake"><a href="#Windows-MinGW-CMake" class="headerlink" title="Windows MinGW + CMake"></a>Windows MinGW + CMake</h2><p>Windows默认使用nmake编译，如果我们要使用 <code>MinGW</code> 来编译需要指定命令行参数。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br></pre></td></tr></table></figure><p>如果需要在 <code>cmake</code> 生成makefile文件的基础上构建项目，我们需要使用 <code>make</code> 命令，可以在 <code>MinGW</code> 编译器的 <code>bin</code> 文件夹下找到 <code>mingw32-make.exe</code> 文件，复制一份将名称重命名为 <code>make.exe</code> 。注意你也需要保证 <code>MinGW</code> 已经配置在环境变量中。</p><p>然后你就可以正常使用<code>cmake</code> 生成makefile文件和并且使用 <code>make</code> 来构建项目了。</p><p>一键命令，需要在Windows下，使用MinGW编译器，且命令行窗口为cmd：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目根目录</span><br><span class="line"><span class="built_in">rmdir</span> /s/q build &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake -G &quot;MinGW Makefiles&quot; .. &amp;&amp; make</span><br></pre></td></tr></table></figure><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>在 <code>Demo</code> 文件夹下的目录树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|─ CMakeLists.txt</span><br><span class="line">|─ main.cpp</span><br><span class="line">|─ utils.cpp</span><br><span class="line">|─ utils.hpp</span><br><span class="line">|─ build</span><br></pre></td></tr></table></figure><p>utils.hpp：头文件，hpp是C++头文件的一种写法，此文件中不仅可以定义，也可以进行对应实现，不过下面没有体现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>utils.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">double</span>)a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub</span>(a, b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">mul</span>(a, b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">divd</span>(a, b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(Demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp utils.cpp)</span><br></pre></td></tr></table></figure><p>一般我们会让cmake的结果存在另外一个新建的build目录，防止生成内容和已有项目产生混乱。在build目录中执行命令：（此时采用的是Windows MinGW编译器）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br></pre></td></tr></table></figure><p>然后在build文件夹中执行 <code>make</code> 命令即可构建可执行程序完成。</p><h2 id="各命令介绍"><a href="#各命令介绍" class="headerlink" title="各命令介绍"></a>各命令介绍</h2><h3 id="1-cmake-minimum-required"><a href="#1-cmake-minimum-required" class="headerlink" title="1 cmake_minimum_required"></a>1 cmake_minimum_required</h3><p>作用：指定使用的 cmake 的最低版本</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure><h3 id="2-project"><a href="#2-project" class="headerlink" title="2 project"></a>2 project</h3><p>作用：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">       [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [LANGUAGES &lt;language-name&gt;...])</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(Demo)</span><br></pre></td></tr></table></figure><h3 id="3-add-executable"><a href="#3-add-executable" class="headerlink" title="3 add_executable"></a>3 add_executable</h3><p>作用：添加可执行程序名称和源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure><p>这样生成的可执行程序的名称就为指定的名称，源文件为 <code>.c .cpp</code> 文件，可以为多个，多个文件用空格或者 <code>;</code> 隔开。</p><h3 id="4-set"><a href="#4-set" class="headerlink" title="4 set"></a>4 set</h3><p>作用：定义变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(NAME [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure><p>定义之后就可以使用 <code>$&#123;&#125;</code> 使用变量了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST utils.cpp main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-搜索文件"><a href="#5-搜索文件" class="headerlink" title="5 搜索文件"></a>5 搜索文件</h3><h4 id="5-1-aux-source-directory"><a href="#5-1-aux-source-directory" class="headerlink" title="5.1 aux_source_directory"></a>5.1 aux_source_directory</h4><p>作用：查找某个路径下的所有源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><h4 id="5-2-file"><a href="#5-2-file" class="headerlink" title="5.2 file"></a>5.2 file</h4><p>作用：搜索文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure><blockquote><p>注意：通过file搜索出来的都是绝对路径</p></blockquote><p>此处可以选两个参数：</p><ul><li>GLOB：将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li><li>GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure><h3 id="6-include-directories"><a href="#6-include-directories" class="headerlink" title="6 include_directories"></a>6 include_directories</h3><p>作用：包含头文件，指定头文件路径，便可包含此路径下的头文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br></pre></td></tr></table></figure><h3 id="7-add-library"><a href="#7-add-library" class="headerlink" title="7 add_library"></a>7 add_library</h3><p>有些源代码我们不需要将其编译成可执行程序，而是制作成静态库或动态库文件让第三方使用。</p><h4 id="7-1-制作动态库"><a href="#7-1-制作动态库" class="headerlink" title="7.1 制作动态库"></a>7.1 制作动态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...)</span><br></pre></td></tr></table></figure><p>动态库的最终库名分为三部分：<code>lib</code> + <code>库名</code> + <code>.so</code> ，我们只需要指定库名即可。</p><h4 id="7-2-制作静态库"><a href="#7-2-制作静态库" class="headerlink" title="7.2 制作静态库"></a>7.2 制作静态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...)</span><br></pre></td></tr></table></figure><p>静态库的最终库名分为三部分：<code>lib</code> + <code>库名</code> + <code>.a</code> ，我们只需要指定库名即可。</p><h3 id="8-加载库文件"><a href="#8-加载库文件" class="headerlink" title="8 加载库文件"></a>8 加载库文件</h3><p>动态库和静态库的区别：</p><ul><li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li><li>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存。所以在cmake中，<strong>需要将动态库链接的命令写在生成了可执行文件（即add_executable）之后</strong></li></ul><h4 id="8-1-link-libraries-加载静态库"><a href="#8-1-link-libraries-加载静态库" class="headerlink" title="8.1 link_libraries 加载静态库"></a>8.1 link_libraries 加载静态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure><ul><li>参数1：指定出要链接的静态库的名字 <ul><li>可以是全名 <code>libxxx.a</code></li><li>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字 <code>xxx</code></li></ul></li><li>参数2-N：要链接的其它静态库的名字</li></ul><h4 id="8-2-target-link-libraries-加载动态库"><a href="#8-2-target-link-libraries-加载动态库" class="headerlink" title="8.2 target_link_libraries 加载动态库"></a>8.2 target_link_libraries 加载动态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure><blockquote><p><code>target_link_libraries</code> 既可以链接动态库文件，也可以链接静态库文件。</p></blockquote><h3 id="9-message"><a href="#9-message" class="headerlink" title="9 message"></a>9 message</h3><p>作用：打日志信息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure><ul><li><code>(无)</code> ：重要消息</li><li><code>STATUS</code> ：非重要消息</li><li><code>WARNING</code>：CMake 警告, 会继续执行</li><li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li><li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li>FATAL_ERROR：CMake 错误, 终止所有处理过程</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="10-list"><a href="#10-list" class="headerlink" title="10 list"></a>10 list</h3><h4 id="10-1-append拼接"><a href="#10-1-append拼接" class="headerlink" title="10.1 append拼接"></a>10.1 append拼接</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><p><code>APPEND</code> 表示数据追加，把 <code>element</code> 追加到 <code>list</code> 中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="10-2-remove-item移除"><a href="#10-2-remove-item移除" class="headerlink" title="10.2 remove_item移除"></a>10.2 remove_item移除</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure><h3 id="11-add-definitions"><a href="#11-add-definitions" class="headerlink" title="11 add_definitions"></a>11 add_definitions</h3><p>作用：添加宏定义</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure><h2 id="Cmake嵌套"><a href="#Cmake嵌套" class="headerlink" title="Cmake嵌套"></a>Cmake嵌套</h2><p>在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件。</p><p>嵌套的 CMake 是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。以下是关于 CMakeLists.txt 文件变量作用域的一些信息：</p><ul><li>根节点<code>CMakeLists.txt</code>中的变量全局有效</li><li>父节点<code>CMakeLists.txt</code>中的变量可以在子节点中使用</li><li>子节点<code>CMakeLists.txt</code>中的变量只能在当前节点中使用</li></ul><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="1-条件判断"><a href="#1-条件判断" class="headerlink" title="1 条件判断"></a>1 条件判断</h3><p>判断语句结构如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) </span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              </span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>条件判断方面：</p><ul><li>有 <code>NOT, AND, OR</code> 逻辑运算符</li><li>有 <code>LESS, GREATER, EQUAL, LESS_EQUAL, GREATER_EQUAL</code> 数值比较运算符</li><li>还有文件相关的判断 <ul><li><code>EXISTS path</code> ：判断 <code>path</code> 路径对应的文件或目录是否存在</li><li><code>IS_DIRECTORY path</code> ：判断是不是目录，<code>path</code> 需要为绝对路径</li><li><code>IS_ABSOLUTE path</code> ：判断是不是绝对路径</li></ul></li></ul><h3 id="2-循环"><a href="#2-循环" class="headerlink" title="2 循环"></a>2 循环</h3><h4 id="2-1-foreach"><a href="#2-1-foreach" class="headerlink" title="2.1 foreach"></a>2.1 foreach</h4><p>结构：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><ul><li><code>foreach(var RANGE stop)</code> ：取值范围为 <code>[0, stop]</code> ，每次取值都会将值放到变量 <code>var</code> 中。</li><li><code>foreach(var RANGE start stop step)</code> ：取值范围为 <code>[start, stop]</code>，每次取值都会将值放到变量 <code>var</code> 中，步长为 <code>step</code> 。</li><li><code>foreach(var IN lists)</code> ：每次取<code>lists</code>中的值放到 <code>var</code> 中，<code>lists</code> 可以为多个。</li></ul><h4 id="2-2-while"><a href="#2-2-while" class="headerlink" title="2.2 while"></a>2.2 while</h4><p>结构：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="1-预定义宏"><a href="#1-预定义宏" class="headerlink" title="1 预定义宏"></a>1 预定义宏</h3><p>列举cmake自带的宏，可以对宏进行指定变量，按照我们的意图去进行相关操作。</p><table><thead><tr><th>宏</th><th>介绍</th></tr></thead><tbody><tr><td>PROJECT_SOURCE_DIR</td><td>使用cmake命令时，后面紧跟的目录，一般是工程的根目录</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>执行cmake命令时的目录</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>当前处理的CMakeLists.txt所在的路径</td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>target 编译目录</td></tr><tr><td>EXECUTABLE_OUTPUT_PATH</td><td>重新定义目标二进制可执行文件的存放位置，可以指定动态库生成路径</td></tr><tr><td>LIBRARY_OUTPUT_PATH</td><td>重新定义目标链接库文件的存放位置，可以指定静态库和动态库生成路径</td></tr><tr><td>PROJECT_NAME</td><td>返回通过PROJECT指令定义的项目名称</td></tr><tr><td>CMAKE_BINARY_DIR</td><td>项目实际构建路径，假设在 <code>build</code><br /> 目录进行的构建，那么得到的就是这个目录的路径</td></tr></tbody></table><p>也可以自定义指定上述宏的路径，如</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HOME /home/wyq/Demo)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure><h3 id="2-其他宏"><a href="#2-其他宏" class="headerlink" title="2 其他宏"></a>2 其他宏</h3><ul><li>CMAKE_CXX_STANDARD</li></ul><p>项目编译的语言标准，可以进行指定</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：</p><p>[1] CMake保姆级教程（上）<a href="https://subingwen.cn/cmake/CMake-primer/index.html">https://subingwen.cn/cmake/CMake-primer/index.html</a></p><p>[2] CMake保姆级教程（下）<a href="https://subingwen.cn/cmake/CMake-advanced/">https://subingwen.cn/cmake/CMake-advanced/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmake </tag>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2024/03/01/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/01/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h2><ul><li>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上</li><li>容器是完全使用沙箱机制，相互隔离</li><li>容器开销极低</li><li>总结：Docker是一种容器技术，解决软件跨环境迁移的问题</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget 从https://get.docker.com获取并运行Docker </span></span><br><span class="line"><span class="comment"># 安装脚本，然后采用Shell中管道（pipe）的方式来执行这个脚本</span></span><br><span class="line">wget -qO- https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最好通过非root用户来使用Docker。这时需要添加非root用户</span></span><br><span class="line"><span class="comment"># 到本地Docker Unix组当中。下面的命令展示了如何把名为</span></span><br><span class="line"><span class="comment"># jsc的用户添加到Docker组中，</span></span><br><span class="line">sudo usermod -aG docker jsc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line"><span class="built_in">cat</span> /etc/group | grep docker</span><br><span class="line"><span class="comment"># docker:x:998:jsc</span></span><br><span class="line"></span><br><span class="line">docker --version</span><br></pre></td></tr></table></figure><h3 id="将Docker配置为开机自启动："><a href="#将Docker配置为开机自启动：" class="headerlink" title="将Docker配置为开机自启动："></a>将Docker配置为开机自启动：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line">systemctl is-enable docker <span class="comment"># 查看状态</span></span><br></pre></td></tr></table></figure><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ul><li><strong>镜像（Image）</strong>：相当于是一个root文件系统</li><li><strong>容器（Container）</strong>：镜像和容器的关系，就像类和对象的关系，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停。</li><li><strong>仓库（Repository）</strong>：代码控制中心，用来保存镜像</li></ul><h2 id="配置Docker镜像加速"><a href="#配置Docker镜像加速" class="headerlink" title="配置Docker镜像加速"></a>配置Docker镜像加速</h2><p>阿里云镜像加速器地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lpoyvph5.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure><p>可以通过修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://a3e6u0iu.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line"> <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line"> <span class="string">&quot;https://mirror.baidubce.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p><a href="https://www.cnblogs.com/xiaobear/p/16660475.html">Docker常用命令大全（万字详解） - 小熊学Java - 博客园 (cnblogs.com)</a></p><h3 id="启动相关命令"><a href="#启动相关命令" class="headerlink" title="启动相关命令"></a>启动相关命令</h3><ul><li><p><strong>启动docker</strong>：<code>systemctl start docker</code></p></li><li><p><strong>查看运行状态：</strong><code>systemctl status docker</code></p></li><li><p>停止：<code>systemctl stop docker</code></p></li><li><p>重启：<code>systemctl restart docker</code></p></li></ul><h3 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h3><h4 id="查看本机镜像："><a href="#查看本机镜像：" class="headerlink" title="查看本机镜像："></a><strong>查看本机镜像</strong>：</h4><p><code>docker images</code></p><p>各个选项说明:</p><ul><li>REPOSITORY：表示镜像的仓库源(也就是名称</li><li>TAG：镜像的标签版本号</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul><blockquote><p>同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</p></blockquote><p>OPTIONS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a :列出本地所有的镜像（含历史映像层）</span><br><span class="line">docker images -a</span><br><span class="line"></span><br><span class="line">-q :只显示镜像ID。</span><br><span class="line">docker images -q</span><br></pre></td></tr></table></figure><h4 id="搜索镜像："><a href="#搜索镜像：" class="headerlink" title="搜索镜像："></a><strong>搜索镜像：</strong></h4><p><code>docker search [OPTIONS] 镜像名字</code></p><p><img src="https://s2.loli.net/2024/03/01/wRvHXigVQ1kPqnt.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/wRvHXigVQ1kPqnt.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="docker search"></p><p>OPTIONS说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># –limit : 只列出N个镜像，默认25个</span></span><br><span class="line">docker search --<span class="built_in">limit</span> 5 redis</span><br></pre></td></tr></table></figure><h4 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h4><p><code>docker pull 镜像名</code>[:TAG]</p><ul><li>没有TAG就是最新版</li><li>等价于：<code>docker pull 镜像名字:latest</code></li></ul><p>如果想找某个特定版本的镜像，但不知道有没有，可以去docker hub官网：<a href="https://hub.docker.com/">hub.docker.com</a>找到对应的仓库，然后寻找版本号</p><img src="https://s2.loli.net/2024/03/01/6KwIpUFfecBiXDG.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/6KwIpUFfecBiXDG.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="docker hub: redis" style="zoom: 80%;" /><h4 id="删除镜像："><a href="#删除镜像：" class="headerlink" title="删除镜像："></a><strong>删除镜像：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><p><strong>1、删除单个</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi  -f 镜像ID</span><br></pre></td></tr></table></figure><p><strong>2、删除多个</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br></pre></td></tr></table></figure><p><strong>3、删除全部</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -qa)</span><br><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p><p><code>--name=</code>“容器新名字” 为容器指定一个名称；</p><p><code>-d</code>: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p><p><code>-i</code>：以交互模式运行容器，通常与 <code>-t</code> 同时使用；</p><p><code>-t</code>：为容器重新分配一个伪输入终端，通常与 <code>-i</code> 同时使用；即启动交互式容器(前台有伪终端，等待交互)；</p><p><code>-P</code>: 随机端口映射，大写P</p><p><code>-p</code>: 指定端口映射，小写p</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并在bash命令行中打开，exit退出后容器就关闭</span></span><br><span class="line">docker run -it --name=<span class="built_in">test</span> ubuntu:latest /bin/bash</span><br><span class="line"><span class="comment"># 创建容器，在后台运行, 通过docker exec进入，exit后不关闭</span></span><br><span class="line">docker run -<span class="built_in">id</span> --name=test_d centos</span><br><span class="line">docker <span class="built_in">exec</span> -it test_d /bin/bash</span><br></pre></td></tr></table></figure><p><code>/bin/bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</p><p>要退出终端，直接输入 <code>exit</code>:</p><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><p><code>docker ps [OPTIONS]</code></p><p>OPTIONS说明（常用）：</p><p><code>-a</code> :列出当前所有正在运行的容器+历史上运行过的</p><p><code>-l</code> :显示最近创建的容器。</p><p><code>-n</code>：显示最近n个创建的容器。</p><p><code>-q</code> :静默模式，只显示容器编号。</p><h4 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a><strong>启动已停止运行的容器</strong></h4><p><code>docker start 容器ID或者容器名</code></p><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a><strong>重启容器</strong></h4><p><code>docker restart 容器ID或者容器名</code></p><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a><strong>停止容器</strong></h4><p><code>docker stop 容器ID或者容器名</code></p><h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a><strong>强制停止容器</strong></h4><p><code>docker kill 容器ID或者容器名</code></p><h4 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a><strong>删除已停止的容器</strong></h4><p><code>docker rm 容器ID</code></p><h4 id="一次性删除多个容器实例"><a href="#一次性删除多个容器实例" class="headerlink" title="一次性删除多个容器实例"></a><strong>一次性删除多个容器实例</strong></h4><p><code>docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm</code></p><h4 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a><strong>查看容器内部细节</strong></h4><p><code>docker inspect 容器ID</code></p><h2 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h2><h3 id="数据卷概念及作用"><a href="#数据卷概念及作用" class="headerlink" title="数据卷概念及作用"></a>数据卷概念及作用</h3><ul><li>数据卷是宿主机中的一个目录或文件</li><li>当容器目录和数据卷目录绑定后，对方的修改会立即同步</li><li>一个数据卷可以被多个容器同时挂载，一个容器也可以被挂载多个数据卷</li></ul><p><strong>作用：</strong></p><ul><li>容器数据持久化</li><li>外部机器和容器间接通信</li><li>容器之间数据交换</li></ul><blockquote><p>注意：数据卷不会额外占用存储空间，容器内和宿主机共享的文件是同一份！</p></blockquote><h3 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h3><p>创建启动容器时，使用 <code>-v</code> 参数 设置数据卷</p><p><code>docker run … -v 宿主机目录：容器内目录</code></p><blockquote><p>注意事项：</p><ul><li>目录必须是绝对路径</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷 -v .. -v ..</li></ul></blockquote><p>问题：</p><ol><li>在容器中找不到挂载的数据卷？</li></ol><p>先用<code>docker inspect</code> 查看容器的挂载点和映射情况：</p><p><img src="https://s2.loli.net/2024/03/01/nuZUzLD7mJiNMp5.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/nuZUzLD7mJiNMp5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="docker inspect"></p><ol start="2"><li>如何给已有的容器添加数据卷？</li></ol><p><code>docker container update --mount source=my-volume,target=/my-folder my-container</code></p><p>其中，<code>--mount</code>选项指定要挂载的数据卷，<code>source</code>参数指定创建的数据卷的名称，<code>target</code><br>参数指定容器内挂载该数据卷的目录路径，<code>my-container</code>表示要添加数据卷的容器的名称或ID</p><blockquote><p>需要注意的是，如果容器已经运行，需要在修改之后重新启动容器使其生效，但是如果容器已经停止，数据卷仍然会保留。</p></blockquote><blockquote><p>另外，可以通过<code>docker volume inspect my-volume</code>命令来查看数据卷的具体信息，包括挂载点以及卷在之前哪些容器中使用过等。</p></blockquote><h3 id="配置数据卷容器"><a href="#配置数据卷容器" class="headerlink" title="配置数据卷容器"></a>配置数据卷容器</h3><p>多容器进行数据交换</p><p><img src="https://s2.loli.net/2024/03/01/z8V5LjNnIbdKxrU.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/z8V5LjNnIbdKxrU.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据卷"></p><p>c3挂载到宿主机的数据卷上，c1, c2再挂载到c3上，c3就是数据卷容器，c1 c2可以通信</p><ol><li><p>创建启动c3数据卷容器， 使用<code>-v</code>参数设置数据卷</p><p><code>docker run -it --name=c3 -v /volum ubuntu /bin/bash</code></p></li><li><p>创建启动 c1, c2容器，使用 <code>--volumes-from</code>参数设置数据卷</p><p><code>docker run -it --name=c1 --volumes-from c3 ubuntu /bin/bash</code></p><p><code>docker run -it --name=c2 --volumes-from c3 ubuntu /bin/bash</code></p></li></ol><h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><ul><li>容器内的网络服务和外部机器不能直接通信</li><li>外部机器和宿主机可以直接通信，宿主机和容器可以直接通信</li><li>当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上，外部机器访问宿主机的该端口，从而简介访问容器的服务。</li></ul><img src="https://s2.loli.net/2024/03/01/aQ9I4siCgekuyNc.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/aQ9I4siCgekuyNc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="通过把容器中的3306端口映射到宿主机的3307端口，使得外部机器可以和容器通信" style="zoom:80%;" /><p>通过把容器中的3306端口映射到宿主机的3307端口，使得外部机器可以和容器通信</p><h3 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h3><p>需求：在Docker容器中部署MySQL，通过外部MySQL客户端操作MySQL Server</p><p>基本步骤：</p><ol><li><p>搜索MySQL镜像</p><p><code>docker search mysql</code></p></li><li><p>拉取MySQL镜像</p><p><code>docker pull mysql</code></p><p>这里可以在hub.docker.com找到你想拉取的版本</p></li><li><p>创建容器 设置端口映射，目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/dockerProj/mysql</span><br><span class="line"><span class="built_in">cd</span> ~/dockerProj/mysql</span><br><span class="line"></span><br><span class="line">docker run -<span class="built_in">id</span> \</span><br><span class="line">-p 3307:3306 \</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d \</span><br><span class="line">-v <span class="variable">$PWD</span>/logs:/logs \</span><br><span class="line">-v <span class="variable">$PWD</span>/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-p 3307:3306</code> ：将容器的<code>3306</code>端口映射到宿主机的<code>3307</code>端口（这里不一样只为了区分宿主机还是容器，实际使用时可以设置一样的端口）</li><li><code>-v  $PWD/conf:/etc/mysql/conf.d</code> ：将主机当前目录下的<code>conf/my.cnf</code>挂载到容器的<code>/etc/mysql/my.cnf</code> 配置目录</li><li><code>-v $PWD/logs:/logs</code> ：将主机当前目录下的<code>logs</code>目录挂载到容器的&#x2F;logs日志目录</li><li><code>-v $PWD/data:/var/lib/mysql</code> ：将主机当前目录下的<code>data</code>目录挂载到容器的<code>/var/lib/mysql</code> 数据目录</li><li><code>-e MYSQL_ROOT_PASSWORD=123456</code> ：初始化root用户的密码</li></ul><p>进入容器：<code>docker exec -it c_mysql /bin/bash</code></p></li><li><p>操作容器中的MySQL</p><p>以SQLyog为例：</p><p><img src="https://s2.loli.net/2024/03/01/k1OVRAfPyLDE8q3.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/k1OVRAfPyLDE8q3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://s2.loli.net/2024/03/01/lQYk8MK73tjqwXV.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/lQYk8MK73tjqwXV.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://s2.loli.net/2024/03/01/NTfbOjQR1mFp4Yt.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/NTfbOjQR1mFp4Yt.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p></li></ol><h3 id="nginx部署"><a href="#nginx部署" class="headerlink" title="nginx部署"></a>nginx部署</h3><p>基本步骤一致，有一个需要注意的地方是 nginx配置文件的映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -<span class="built_in">id</span> --name=c_nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-v <span class="variable">$PWD</span>/conf/nginx/conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v <span class="variable">$PWD</span>/logs:/var/log/nginx \</span><br><span class="line">-v <span class="variable">$PWD</span>/html:/user/shar/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-v $PWD/conf/nginx/conf:/etc/nginx/nginx.conf</code> ：将主机当前目录下的<code>/conf/nginx.conf</code>挂载到容器的 <code>/etc/nginx/nginx.conf</code>配置目录。</li></ul><p>这里要注意的是，这个<code>nginx.conf</code>需要提前准备，或者先创建一个nginx容器后把这个配置文件拷贝出来，再删除这个容器，重新创建一个容器并挂载拷贝出来的配置文件</p><p>Nginx 的官方配置文件可以在官方网站上找到，也可以在 GitHub 上查看官方仓库中的 <code>nginx.conf</code> 文件。</p><p>官方网站链接为：<a href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></p><p>GitHub 仓库链接为：<a href="https://github.com/nginx/nginx/blob/master/conf/nginx.conf">https://github.com/nginx/nginx/blob/master/conf/nginx.conf</a></p><p>在该网站上，你可以找到官方文档和相关指南。其中，Nginx 的配置指南就包含了默认配置文件的详细说明。注意，该文件可能会随着 Nginx 版本的更新而发生变化。</p><ul><li><p>附：nginx.conf 官方配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>用于创建docker镜像</p><h3 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h3><ul><li><p>操作系统组成部分：</p><ul><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ul><p>Linux文件系统由<code>bootfs</code>和<code>rootfs</code>两部分组成</p><ul><li><p><code>bootfs</code>：包含<code>bootloader</code>（引导加载程序）和<code>kernel</code>(内核)</p></li><li><p><code>rootfs</code>：root文件系统，包含的就是典型Linux系统中的&#x2F;dev, &#x2F;bin, &#x2F;etc等标准目录文件</p></li><li><p>不同的Linux发行版， <code>bootfs</code>基本一样，而<code>rootfs</code>不同，如Ubuntu， centos</p><img src="https://s2.loli.net/2024/03/01/ozJcCkQVafwDpBU.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/ozJcCkQVafwDpBU.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom:67%;" /></li></ul></li><li><p>Docker镜像原理：</p><ul><li><p>Docker镜像是由特殊的文件系统叠加而成，最底端是<code>bootfs</code>，并使用宿主机的<code>bootfs</code>，第二层是<code>root</code>文件系统<code>rootfs</code>，称为<code>base image</code>，再往上可以叠加其他的镜像文件</p></li><li><p>统一文件系统(Union File System)技术能将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户角度看，只存在一个文件系统</p></li><li><p>一个镜像文件可以放在另一个镜像文件上面。位于下面的镜像称为父镜像，最底层的镜像称为基础镜像。</p></li><li><p>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</p><p><img src="https://s2.loli.net/2024/03/01/InlFUYWMPs9fGLE.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/InlFUYWMPs9fGLE.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p></li></ul><p>只读镜像是不能改的，要想修改镜像，可以使用该镜像创建一个容器，对容器进行修改后创建成一个新的镜像</p><p>​    </p></li><li><p>相关问题</p><ol><li><p>Docker镜像的本质是什么？</p><p>是一个分层文件系统</p></li><li><p>Docker中一个centos镜像为什么只有200MB，而一个centos操作系统的ISO文件上G</p><p>centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层</p></li><li><p>Docker中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？</p><p>docker中镜像是分层的，tomcat虽然只有70MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像就达到了500MB</p></li></ol></li></ul><h3 id="容器提交为镜像"><a href="#容器提交为镜像" class="headerlink" title="容器提交为镜像"></a>容器提交为镜像</h3><p>制作docker镜像有两种方式，一种是容器转为镜像，另一种是通过dockerfile制作</p><p>先看容器如何转为镜像：</p><p><img src="https://s2.loli.net/2024/03/01/QqGyJpYsEKBWOzX.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/QqGyJpYsEKBWOzX.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="容器转镜像"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器<span class="built_in">id</span> 镜像名称:版本号</span><br><span class="line">docker save -o 压缩文件名称 镜像名称:版本号</span><br><span class="line">docker load -i 压缩文件名称</span><br></pre></td></tr></table></figure><p>注意：容器的挂载信息不会commit到新的镜像</p><h3 id="Dockerfile概念及作用"><a href="#Dockerfile概念及作用" class="headerlink" title="Dockerfile概念及作用"></a>Dockerfile概念及作用</h3><h4 id="dockerfile概念"><a href="#dockerfile概念" class="headerlink" title="dockerfile概念"></a>dockerfile概念</h4><ul><li>dockerfile是一个文本文件，包含了一条条指令</li><li>每条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li></ul><p>Dockerfile是Docker镜像的构建文件，是一个文本文件，包含一系列指令和参数，用于自动化构建Docker镜像。Dockerfile中的关键字是用于构建镜像的指令和参数，通过这些指令和参数可以构建出一个完整的Docker镜像。</p><h4 id="常见的Dockerfile关键字："><a href="#常见的Dockerfile关键字：" class="headerlink" title="常见的Dockerfile关键字："></a>常见的Dockerfile关键字：</h4><ul><li><code>FROM</code>：指定基础镜像，即当前镜像是基于哪个镜像构建的，通常是一个操作系统镜像。</li><li><code>MAINTAINER</code>：指定镜像作者信息，即构建此镜像的作者和联系方式。</li><li><code>LABEL</code>：设置镜像的元数据，用于设置镜像的元数据，包括名称、版本、描述等信息。可以用<code>LABEL</code>代替<code>MAINTAINER</code>，最终都可以在<code>docker image</code>基本信息中查看</li><li><code>RUN</code>：在镜像中执行命令，用于安装软件包、更新系统等操作。默认是<code>/bin/sh</code> 格式：<code>RUN command</code>或者 <code>RUN [”command”, “param1”, “param2”]</code></li><li><code>ADD</code>：复制文件或目录到镜像中，将指定的文件或目录从构建环境复制到镜像中，支持自动解压缩。</li><li><code>COPY</code>：build的时候复制文件或目录到镜像中，与ADD类似，不支持自动解压</li><li><code>CMD</code>：容器启动后执行的命令，可以被覆盖，如果Dockerfile中有多个CMD指令，只有最后一个会生效。提供启动容器时的默认命令，和<code>ENTRYPOINT</code>配合使用，格式 <code>CMD command param1 param2</code> 或者<code>CMD [”command”, “param1”, “param2”]</code></li><li><code>ENTRYPOINT</code>：容器启动后执行的命令，与<code>CMD</code>类似，但是不可被覆盖，可以通过指定参数来修改其默认行为。<em>一般在制作一些执行就关闭的容器中使用</em></li><li><code>EXPOSE</code>：指定容器监听的网络端口，为容器设置端口映射。格式<code>EXPOSE 80</code></li><li><code>ENV</code>：在容器中设置环境变量。指定<code>build</code>时的环境变量，可以在启动容器的时候通过 <code>-e</code> 覆盖，格式 <code>ENV name=value</code></li><li><code>WORKDIR</code>：容器中的工作目录，指定容器内工作目录，所有后续的命令都会在此目录下执行。如果使用<code>/</code>开头的地址，则是绝对地址，如果不是<code>/</code>开头的地址，是在上一条<code>WORKDIR</code>的路径下的相对路径</li><li><code>USER</code>：指定运行容器的用户，用于设置容器中的用户。</li><li><code>VOLUME</code>：用于在容器中创建一个挂载点，可以在运行容器时将主机目录挂载到容器中。格式 <code>VOLUME [”目录”]</code></li><li><code>ARG</code>：定义构建时的变量，用于在构建镜像时动态设置变量。只在构建的时候使用的参数，如果有<code>ENV</code>，那么<code>ENV</code>中相同名字的值始终覆盖<code>ARG</code>的参数</li><li><code>HEALTHCHECK</code>：健康检查，基本没用</li><li><code>ONBUILD</code>：触发器，当存在<code>ONBUILD</code>关键字的镜像作为基础镜像时，执行<code>FROM</code>完成后，会执行<code>ONBUILD</code>命令，不影响当前镜像</li><li><code>STOPSIGNAL</code>：发送信号量到宿主机，STOPSIGNAL指令</li><li><code>SHELL</code>：指定执行脚本(<code>RUN CMD ENTRYPOINT</code>命令)的<code>shell</code></li></ul><h3 id="Dockerfile案例"><a href="#Dockerfile案例" class="headerlink" title="Dockerfile案例"></a>Dockerfile案例</h3><h4 id="部署sprintboot项目"><a href="#部署sprintboot项目" class="headerlink" title="部署sprintboot项目"></a>部署sprintboot项目</h4><p>需求：定义dockerfile，发布springboot项目</p><p>步骤：</p><ol><li>在把sprintboot项目打包为jar包，传到宿主机中(springboot.jar)</li><li>编写dockerfile</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> sunhk &lt;shk@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> springboot.jar app.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> java -jar app.jar</span></span><br></pre></td></tr></table></figure><ol><li>通过dockerfile构建镜像：<code>docker build -f dockerfile文件路径 -t 镜像名称:版本.</code></li></ol><h4 id="自定义centos"><a href="#自定义centos" class="headerlink" title="自定义centos"></a>自定义centos</h4><p>需求：自定义一个centos镜像，要求默认登录路径为<code>/user</code> ，可以使用<code>vim</code></p><p>dockerfile：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> sunhk &lt;shk@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y vim</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><p>构建镜像：<code>docker build -f ./centos_dockerfile -t usr_centos:1 .</code></p><h4 id="问题：yum安装报错："><a href="#问题：yum安装报错：" class="headerlink" title="问题：yum安装报错："></a>问题：yum安装报错：</h4><p>暂时未解决，但思路就是在dockerfile中增加一个换源的步骤</p><p>该错误通常是由于 Docker 容器构建环境中的 CentOS 操作系统镜像无法正常访问 CentOS 的软件仓库所致。解决方法如下：</p><ol><li>指定国内的软件仓库。</li></ol><p>在 Dockerfile 中，在安装软件包之前添加以下命令，使用阿里云的 CentOS 软件仓库：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    yum clean all &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    yum makecache</span></span><br></pre></td></tr></table></figure><ol><li>增加额外的仓库镜像。</li></ol><p>在 Dockerfile 中，添加以下命令，使用阿里云的 Extra Packages for Enterprise Linux (EPEL) 镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y epel-release</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h3><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大：</p><ul><li>要从Dockerfile build image或者去dockerhub拉取image</li><li>要创建并管理（启动停止删除）多个容器，</li></ul><p>服务编排：按照一定的业务规则批量管理容器</p><h3 id="Docker-Compose-1"><a href="#Docker-Compose-1" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><code>docker compose</code>是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</p><ol><li>利用Dockerfile定义运行环境镜像</li><li>使用<code>docker-compose.yml</code>定义组成应用的各服务</li><li>运行<code>docker-compose up</code> 启动应用</li></ol><img src="https://s2.loli.net/2024/03/01/LRrhqYnBeu8KGIZ.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/LRrhqYnBeu8KGIZ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="docker compose" style="zoom:80%;" /><h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以编译好的二进制包方式安装</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment"># 设置可执行权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h3 id="卸载Docker-Compose"><a href="#卸载Docker-Compose" class="headerlink" title="卸载Docker Compose"></a>卸载Docker Compose</h3><p>二进制包方式安装的，删除二进制文件即可</p><p><code>rm /user/local/bin/docker-compose</code></p><h3 id="使用docker-compose编排ngnix-springboot项目"><a href="#使用docker-compose编排ngnix-springboot项目" class="headerlink" title="使用docker compose编排ngnix+springboot项目"></a>使用docker compose编排ngnix+springboot项目</h3><ol><li><p>创建docker-compose目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/docker-compose</span><br><span class="line"><span class="built_in">cd</span> ~/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>编写docker-compose.yml文件（文件名是固定的！）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">nginx:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">./nginx/conf.d:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">app</span></span><br><span class="line"><span class="attr">expose:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;8080&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>创建.&#x2F;nginx&#x2F;conf.d目录</p></li></ol><h2 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h2><p>Docker官方的docker hub是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法联网，或者不希望将自己的镜像放到公网中，那我们就需要搭建自己的私有仓库来存储和管理自己的镜像</p><h3 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 拉取私有仓库镜像</span></span><br><span class="line">docker pull registry</span><br><span class="line"><span class="comment"># 2. 启动私有仓库容器</span></span><br><span class="line">docker run -<span class="built_in">id</span> --name-registry -p 5000:5000 registry</span><br><span class="line"><span class="comment"># 3. 打开浏览器，输入地址：http://192.168.94.131:5000/v2/_catalog</span></span><br><span class="line"><span class="comment">#    看到 &#123;&quot;repositories&quot;:[]&#125; 表示私有仓库搭建成功</span></span><br><span class="line"><span class="comment"># 4. 修改daemon.json</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 在上述文件中添加一个key，让docker信任私有仓库地址，注意将私有仓库服务器IP修改为自己的</span></span><br><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>: [192.168.94.131:5000]&#125;</span><br><span class="line"><span class="comment"># 5. 重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure><h3 id="上传镜像到私有仓库"><a href="#上传镜像到私有仓库" class="headerlink" title="上传镜像到私有仓库"></a>上传镜像到私有仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 标记镜像为私有仓库的镜像</span></span><br><span class="line">docker tag centos:7 192.168.94.131:5000/centos:7</span><br><span class="line"><span class="comment"># 2. 上传标记的镜像</span></span><br><span class="line">docker push 192.168.94.131:5000/centos:7</span><br></pre></td></tr></table></figure><h3 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.94.131:5000/centos:7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake简单教程--以HelloWorld为例</title>
      <link href="/2024/03/01/Cmake%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B-%E4%BB%A5HelloWorld%E4%B8%BA%E4%BE%8B/"/>
      <url>/2024/03/01/Cmake%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B-%E4%BB%A5HelloWorld%E4%B8%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>cmake的定义是什么 ？—–高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的——简单</p><p>官方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C&#x2F;C++&#x2F;JAVA项目做准备</p><img src="https://s2.loli.net/2024/03/01/g5eGavU7wyNKVbA.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/01/g5eGavU7wyNKVbA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="cmake, make与Makefile" style="zoom:67%;" /><h2 id="CMake安装"><a href="#CMake安装" class="headerlink" title="CMake安装"></a>CMake安装</h2><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.html</a>  可以下载安装</p><h2 id="CMake一个HelloWord"><a href="#CMake一个HelloWord" class="headerlink" title="CMake一个HelloWord"></a>CMake一个HelloWord</h2><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#main.cpp</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> std::cout &lt;&lt;  <span class="string">&quot;hello word&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#CMakeLists.txt</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">PROJECT</span> (HELLO)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">SET</span>(SRC_LIST main.cpp)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> <span class="variable">$&#123;HELLO_BINARY_DIR&#125;</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span><span class="variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> cmake .</span><br><span class="line"> </span><br><span class="line"> 输出：</span><br><span class="line"> [root@localhost cmake]<span class="comment"># cmake .</span></span><br><span class="line"> CMake Warning (dev) in CMakeLists.txt:</span><br><span class="line">   Syntax Warning in cmake code at</span><br><span class="line"> </span><br><span class="line">     /root/cmake/CMakeLists.txt:<span class="number">7</span>:<span class="number">37</span></span><br><span class="line"> </span><br><span class="line">   Argument <span class="keyword">not</span> separated from preceding token by whitespace.</span><br><span class="line"> This warning is for <span class="keyword">project</span> developers.  Use -Wno-dev to suppress it.</span><br><span class="line"> </span><br><span class="line"> -- The C compiler identification is GNU <span class="number">10.2</span>.<span class="number">1</span></span><br><span class="line"> -- The CXX compiler identification is GNU <span class="number">10.2</span>.<span class="number">1</span></span><br><span class="line"> -- Check for working C compiler: /usr/bin/cc</span><br><span class="line"> -- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line"> -- Detecting C compiler ABI info</span><br><span class="line"> -- Detecting C compiler ABI info - done</span><br><span class="line"> -- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line"> -- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line"> -- Detecting CXX compiler ABI info</span><br><span class="line"> -- Detecting CXX compiler ABI info - done</span><br><span class="line"> -- This is BINARY dir /root/cmake</span><br><span class="line"> -- This is SOURCE dir /root/cmake</span><br><span class="line"> -- Configuring done</span><br><span class="line"> -- Generating done</span><br><span class="line"> -- Build files have been written to: /root/cmake</span><br></pre></td></tr></table></figure><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br>现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> root@localhost cmake]# make</span><br><span class="line"> Scanning dependencies of target hello</span><br><span class="line"><span class="meta prompt_"> [100%</span><span class="language-bash">] Building CXX object CMakeFiles/hello.dir/main.cpp.o</span></span><br><span class="line"> Linking CXX executable hello</span><br><span class="line"><span class="meta prompt_"> [100%</span><span class="language-bash">] Built target hello</span></span><br></pre></td></tr></table></figure><p>5、最终生成了Hello的可执行程序</p><h2 id="CMake一个-HelloWord-的语法介绍"><a href="#CMake一个-HelloWord-的语法介绍" class="headerlink" title="CMake一个 HelloWord 的语法介绍"></a>CMake一个 HelloWord 的语法介绍</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a><strong>PROJECT关键字</strong></h3><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p><code>PROJECT (HELLO)</code>          指定了工程的名字，并且支持所有语言—建议</p><p><code>PROJECT (HELLO CXX)</code>      指定了工程的名字，并且支持语言是C++</p><p><code>PROJECT (HELLO C CXX)</code>    指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><code>&lt;projectname&gt;_BINARY_DIR</code>，本例中是 <code>HELLO_BINARY_DIR</code></p><p><code>&lt;projectname&gt;_SOURCE_DIR</code>，本例中是 <code>HELLO_SOURCE_DIR</code></p><p><code>MESSAGE</code>关键字就可以直接使用这两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a><strong>SET关键字</strong></h3><p>用来显式的指定变量的</p><p><code>SET(SRC_LIST main.cpp)</code>    <code>SRC_LIST</code>变量就包含了<code>main.cpp</code></p><p>有多个源文件时，也可以 <code>SET(SRC_LIST main.cpp t1.cpp t2.cpp)</code></p><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a><strong>MESSAGE关键字</strong></h3><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li><code>SEND_ERROR</code>，产生错误，生成过程被跳过。</li><li><code>SATUS</code>，     输出前缀为—的信息。</li><li><code>FATAL_ERROR</code>，立即终止所有 cmake 过程.</li></ul><h3 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a><strong>ADD_EXECUTABLE关键字</strong></h3><p>生成可执行文件</p><p><code>ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)</code>     生成的可执行文件名是<code>hello</code>，源文件读取变量<code>SRC_LIST</code>中的内容</p><p>也可以直接写 <code>ADD_EXECUTABLE(hello main.cpp)</code></p><p>上述例子可以简化的写成</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><blockquote><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p></blockquote><h2 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h2><ul><li><p>变量使用<code>$&#123;&#125;</code>方式取值，但是在 <strong>IF 控制语句</strong>中是直接使用变量名</p></li><li><p><code>指令(参数 1 参数 2...)</code> 参数使用括弧括起，参数之间使用<strong>空格或分号</strong>分开。 以上面的 <code>ADD_EXECUTABLE</code> 指令为例，如果存在另外一个 <code>func.cpp</code> 源文件</p><p>就要写成：<code>ADD_EXECUTABLE(hello main.cpp func.cpp)</code>或者<code>ADD_EXECUTABLE(hello main.cpp;func.cpp)</code></p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h3 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a><strong>语法注意事项</strong></h3><ul><li><code>SET(SRC_LIST main.cpp)</code> 可以写成 <code>SET(SRC_LIST “main.cpp”)</code>，<strong>如果源文件名中含有空格，就必须要加双引号</strong></li><li><code>ADD_EXECUTABLE(hello main)</code> 后缀可以不写，他会自动去找.c和.cpp，<strong>最好不要这样写</strong>，可能会有这两个文件main.cpp和main</li></ul><h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会<strong>把生成的临时文件放在build目录下</strong>，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h3 id="外部构建方式举例"><a href="#外部构建方式举例" class="headerlink" title="外部构建方式举例"></a><strong>外部构建方式举例</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> //例子目录，CMakeLists.txt和上面例子一致</span><br><span class="line"> [root@localhost cmake]# pwd</span><br><span class="line"> /root/cmake</span><br><span class="line"> [root@localhost cmake]# ll</span><br><span class="line"> total 8</span><br><span class="line"> -rw-r--r--. 1 root root 198 Dec 28 20:59 CMakeLists.txt</span><br><span class="line"> -rw-r--r--. 1 root root  76 Dec 28 00:18 main.cpp</span><br></pre></td></tr></table></figure><p>1、建立一个<code>build</code>目录，可以在任何地方，建议在当前目录下</p><p>2、进入<code>build</code>，运行<code>cmake ..</code>    当然..表示上一级目录，你可以写<code>CMakeLists.txt</code>所在的绝对路径，生产的文件都在<code>build</code>目录下了</p><p>3、在<code>build</code>目录下，运行<code>make</code>来构建工程</p><blockquote><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid</p></blockquote><h2 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h2><ul><li>为工程添加一个子目录 <code>src</code>，用来放置工程源代码</li><li>添加一个子目录 <code>doc</code>，用来放置这个工程的文档 <code>hello.txt</code></li><li>在工程目录添加文本文件 <code>COPYRIGHT</code>, <code>README</code></li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 <code>hello</code> 二进制</li><li>将构建后的目标文件放入构建目录的 <code>bin</code> 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;</li></ul><h3 id="将目标文件放入构建目录的-bin-子目录"><a href="#将目标文件放入构建目录的-bin-子目录" class="headerlink" title="将目标文件放入构建目录的 bin 子目录"></a><strong>将目标文件放入构建目录的 bin 子目录</strong></h3><p>每个目录下都要有一个<code>CMakeLists.txt</code>说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> [root@localhost cmake]# tree</span><br><span class="line"> .</span><br><span class="line"> ├── build</span><br><span class="line"> ├── CMakeLists.txt</span><br><span class="line"> └── src</span><br><span class="line">     ├── CMakeLists.txt</span><br><span class="line">     └── main.cpp</span><br></pre></td></tr></table></figure><p>外层<code>CMakeLists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PROJECT(HELLO)</span><br><span class="line"> ADD_SUBDIRECTORY(src bin)</span><br></pre></td></tr></table></figure><p><code>src</code>下的CMakeLists.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ADD_EXECUTABLE(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a><strong>ADD_SUBDIRECTORY 指令</strong></h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a><strong>更改二进制的保存路径</strong></h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH {PROJECT_BINARY_DIR}&#x2F;bin)<br>SET(LIBRARY_OUTPUT_PATH {PROJECT_BINARY_DIR}&#x2F;lib)</p><blockquote><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR&#x3D;&#x2F;tmp&#x2F;test</li><li>稍微复杂一点可以这样指定目录：.&#x2F;configure –prefix&#x3D;&#x2F;usr</li></ul></li></ul><h3 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a><strong>如何安装HelloWord</strong></h3><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 目录树结构</span><br><span class="line">[root@localhost cmake]# tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure><h3 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a><strong>安装文件COPYRIGHT和README</strong></h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 &#x2F;usr&#x2F;local&#x2F;</p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a><strong>安装脚本runhello.sh</strong></h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><blockquote><p>说明：实际安装到的是 &#x2F;usr&#x2F;bin</p></blockquote><h3 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a><strong>安装 doc 中的 hello.txt</strong></h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc&#x2F; DESTINATION share&#x2F;doc&#x2F;cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc&#x2F;有很大的区别</p><p>目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的</p><p>目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a><strong>安装过程</strong></h3><p>cmake ..</p><p>make</p><p>make install</p><h2 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h2><p>任务：</p><p>１，建立一个静态库和动态库，提供 <code>HelloFunc</code> 函数供其他程序编程使用，<code>HelloFunc</code> 向终端输出 <code>Hello World</code> 字符串。</p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h3 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a><strong>构建实例</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]# tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a><strong>ADD_LIBRARY</strong></h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库 STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a><strong>同时构建静态和动态库</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a><strong>SET_TARGET_PROPERTIES</strong></h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line">//对hello_static的重名为hello</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">//cmake 在构建一个新的<span class="keyword">target</span> 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a><strong>动态库的版本号</strong></h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so.1.2</span><br><span class="line">libhello.so -&gt;libhello.so.1</span><br><span class="line">libhello.so.1-&gt;libhello.so.1.2</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><blockquote><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p></blockquote><h3 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a><strong>安装共享库和头文件</strong></h3><p>本例中我们将 hello 的共享库安装到<code>&lt;prefix&gt;/lib</code>目录，</p><p>将 hello.h 安装到<code>&lt;prefix&gt;/include/hello</code> 目录</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//文件放到该目录下</span><br><span class="line"><span class="keyword">INSTALL</span>(FILES hello.h DESTINATION <span class="keyword">include</span>/hello)</span><br><span class="line"></span><br><span class="line">//二进制，静态库，动态库安装都用TARGETS</span><br><span class="line">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><blockquote><p>注意：安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p></blockquote><h3 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a><strong>使用外部共享库和头文件</strong></h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]# tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a><strong>解决：make后头文件找不到的问题</strong></h3><p>PS：include &lt;hello&#x2F;hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)</p><h3 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a><strong>解决：找到引用的函数问题</strong></h3><p>报错信息：undefined reference to &#96;HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]# ldd main</span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffedfda4000)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.so (0x00007f41c0d8f000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f41c0874000)</span><br><span class="line">libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f41c0572000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f41c035c000)</span><br><span class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f41bff8e000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000)</span><br></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a><strong>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</strong></h3><blockquote><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p></blockquote><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug</p>]]></content>
      
      
      <categories>
          
          <category> Cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmake </tag>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM中断知识点小记</title>
      <link href="/2024/02/29/ARM%E4%B8%AD%E6%96%AD%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/02/29/ARM%E4%B8%AD%E6%96%AD%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM中断相关知识点小记"><a href="#ARM中断相关知识点小记" class="headerlink" title="ARM中断相关知识点小记"></a>ARM中断相关知识点小记</h1><h2 id="ARM体系中的中断类型"><a href="#ARM体系中的中断类型" class="headerlink" title="ARM体系中的中断类型"></a>ARM体系中的中断类型</h2><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>（1）当处理器复位引脚有效时，系统产生复位中断，程序跳转到复位异常中断处理程序处执行。</p><p>（2）复位源类型：上电复位、外部硬件复位、内部硬件复位（锁相环失锁复位、软件看门狗复位、检错停机复位、调试端口硬复位）、JTAG复位、外部软件复位、内部软件复位（调试端口软复位、JTAG软复位）。</p><h3 id="未定义指令"><a href="#未定义指令" class="headerlink" title="未定义指令"></a>未定义指令</h3><p>（1）当ARM指令处理器或者是系统的协处理器认为当前的指令未定义时，产生未定义指令中断。</p><p>（2）可以通过该中断机制仿真浮点向量运算。</p><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>（1）这是一个<strong>由用户定义的中断指令</strong>，可用于用户模式下的程序调用特权操作指令。</p><p>（2）在实时操作系统中，可以通过该机制实现系统调用功能。</p><h3 id="指令预取中止"><a href="#指令预取中止" class="headerlink" title="指令预取中止"></a>指令预取中止</h3><p>（1）如果<strong>处理器预取的指令</strong>的地址不存在，或者该地址不允许当前指令访问，当该被预取的指令执行时，处理器产生指令预取中止中断。</p><h3 id="数据访问中止"><a href="#数据访问中止" class="headerlink" title="数据访问中止"></a>数据访问中止</h3><p>（1）如果<strong>数据访问指令</strong>的目标地址不存在，或者该地址不允许当前指令访问，处理器产生数据访问中止中断。</p><h3 id="外部中断请求（IRQ）"><a href="#外部中断请求（IRQ）" class="headerlink" title="外部中断请求（IRQ）"></a>外部中断请求（IRQ）</h3><p>（1）当处理器的外部中断请求引脚有效，而且CPSR中的I控制位被清除时，处理器产生外部中断请求中断。</p><p>（2）系统中各个外设通常通过该中断请求处理器服务。</p><h3 id="快速中断请求（FIQ）"><a href="#快速中断请求（FIQ）" class="headerlink" title="快速中断请求（FIQ）"></a>快速中断请求（FIQ）</h3><p>（1）当处理器的外部快速中断请求引脚有效，而且CPSR寄存器中的F控制位被清除时，处理器产生外部快速中断请求中断。</p><h2 id="中断向量表、中断优先级、中断模式、物理寄存器组"><a href="#中断向量表、中断优先级、中断模式、物理寄存器组" class="headerlink" title="中断向量表、中断优先级、中断模式、物理寄存器组"></a>中断向量表、中断优先级、中断模式、物理寄存器组</h2><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>（1）指定了中断及其处理程序的对应关系，通常存放在存储地址的低端。</p><p>（2）在ARM体系中，中断向量表的大小为32个字节，其中每个异常中断占据4个字节大小，保留4个字节空间。</p><p>（3）每个中断向量对应的中断向量表中的4个字节空间存放了一条跳转指令或者一个向PC寄存器中赋值的数据访问指令。</p><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>（1）当几个中断同时发生时，就必须按照一定的次序来处理这些中断。</p><p>（2）在ARM中通过给中断赋予一定的优先级来实现这种处理次序。</p><p>（3）当然有的异常中断是不可能同时发生的，如指令预取中止和软中断是由同一条指令的执行触发的，它们是不可能同时发生的。</p><p>（4）处理器在执行某个中断的过程中，称处理器处于特定的中断模式。</p><h3 id="中断向量-中断模式-中断优先级表"><a href="#中断向量-中断模式-中断优先级表" class="headerlink" title="中断向量&amp;中断模式&amp;中断优先级表"></a>中断向量&amp;中断模式&amp;中断优先级表</h3><table><thead><tr><th align="left">中断向量地址</th><th>异常中断类型</th><th>异常中断模式</th><th>优先级</th></tr></thead><tbody><tr><td align="left">0x0</td><td>复位</td><td>特权模式（SVC）</td><td>1</td></tr><tr><td align="left">0x4</td><td>未定义指令</td><td>未定义指令中断模式</td><td>6</td></tr><tr><td align="left">0x8</td><td>软中断（SWI）</td><td>特权模式（SVC）</td><td>6</td></tr><tr><td align="left">0xC</td><td>指令预取终止</td><td>中止模式</td><td>5</td></tr><tr><td align="left">0x10</td><td>数据访问终止</td><td>中止模式</td><td>2</td></tr><tr><td align="left">0x14</td><td>保留</td><td>未使用</td><td>未使用</td></tr><tr><td align="left">0x18</td><td>外部中断请求</td><td>外部中断模式</td><td>4</td></tr><tr><td align="left">0x1C</td><td>快速中断请求</td><td>快速中断模式</td><td>3</td></tr></tbody></table><h3 id="各种不同的处理器模式对应的物理寄存器组"><a href="#各种不同的处理器模式对应的物理寄存器组" class="headerlink" title="各种不同的处理器模式对应的物理寄存器组"></a>各种不同的处理器模式对应的物理寄存器组</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://s2.loli.net/2024/02/29/YuIgHoXbEKGmr61.jpg" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/29/YuIgHoXbEKGmr61.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="处理器模式对应的物理寄存器组.jpg"></p><h2 id="进入和退出中断的过程"><a href="#进入和退出中断的过程" class="headerlink" title="进入和退出中断的过程"></a>进入和退出中断的过程</h2><ol><li><strong>中断响应及保护现场过程</strong></li></ol><p>（1）首先将<code>R0~R12</code>（其他模式）或<code>R0~R7</code>（快速中断模式）PUSH进堆栈中保存，并将堆栈指针保存在对应工作模式的<code>R13（SP）</code>中。</p><p>（2）把即将执行的下一条指令的地址<code>（PC-4）</code>保存到对应工作模式的<code>R14（LR）</code>中；把<code>CPSR</code>的值保存到对应工作模式的<code>SPSR</code>中，以实现对处理器当前状态、中断屏蔽及各标志位的保护。</p><p>（3）设置<code>CPSR</code>的相应位：设置<code>CPSR[4:0]</code>的5位以进入相应的工作模式；<code>CPSR[5] = 0</code>切换到ARM状态；设置<code>CPSR[7] = 1</code>禁止<code>IRQ</code>中断；如果进入复位模式或<code>FIQ</code>模式，还要设置<code>CPSR[6] = 1</code>以禁止<code>FIQ</code>中断。</p><p>（4）给程序计数器PC强制赋值，转入中断向量地址，执行相应的中断服务程序。</p><ol start="2"><li><strong>恢复现场及中断返回过程</strong></li></ol><p>（1）根据<code>R13</code>即<code>SP</code>的值将原来保存在堆栈中的<code>R0~R12</code>或<code>R0~R7</code> POP出栈，赋值给相应的寄存器。</p><p>（2）将<code>R14</code>即<code>LR</code>的值赋值给PC，将<code>SPSR</code>的值赋值给<code>CPSR</code>中，恢复被中断的程序状态。</p><ol start="3"><li><strong>注意事项</strong></li></ol><p>（1）复位中断处理程序不用返回，因为整个应用系统是从复位中断处理程序开始执行的。</p><p>（2）SWI和未定义指令中断是由当前执行的指令自身产生的，当响应这两种中断时，PC的值还未更新，它指向当前指令后面第二条指令，因此中断返回时执行MOV PC LR即可。</p><p>（3）由于处理器要执行完当前指令再去响应FIQ中断和IRQ中断，这时PC的值已经更新，它指向当前指令后面第三条指令，因此中断返回时要执行SUB PC, LR, #4。</p><ol start="4"><li><strong>ARM体系中控制程序执行流程的三种方式</strong></li></ol><p>（1）正常执行程序的过程中，每执行一条<code>ARM/Thumb-2</code>指令，<code>PC += 4</code>；每执行一条Thumb指令，<code>PC += 2</code>。整个过程是顺序执行。</p><p>（2）通过跳转指令，程序可以跳转到特定的地址标志处执行，或者跳转到特定的子程序处执行。其中，B指令用于执行程序跳转操作；BL指令在执行跳转操作的同时，保存子程序的返回地址；BX指令在执行跳转操作的同时，根据目标地址的最低位可以将程序状态切换到<code>Thumb</code>状态；<code>BLX</code>指令执行三个操作：跳转到目标地址处执行，保存子程序返回地址，根据目标地址最低位可以将程序状态切换到<code>Thumb</code>状态。</p><p>（3）当中断发生时，系统执行完当前指令后，将跳转到相应的中断处理程序处执行。</p><ol start="5"><li><strong>指令流水线</strong></li></ol><p>（1）为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成。</p><p>（2）三级流水线：分成取指令、译码、执行三个阶段，当在执行一条指令的时候，下一条指令已经在译码了，下下条指令已经在取指令了。PC记录的是取指令的指令地址。</p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> 中断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DMA简要介绍</title>
      <link href="/2024/02/28/DMA%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/02/28/DMA%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p>DMA的数据转运可以从外设到存储器，也可以是从存储器到外设，也可以从存储器转运到存储器；转运的次数由传输计数器控制；DMA的触发源有软件触发和硬件触发，</p><p>DMA进行转运的条件：</p><ul><li>第一，<strong>开关控制</strong>，DMA_Cmd必须使能，</li><li>第二，<strong>传输计数器必须大于0</strong>，</li><li>第三，<strong>触发源</strong>，必须有触发信号，触发一次，转运一次，传输计数器自减一次**<br>当传输计数器等于0，且没有自动重装时，无论是否触发，DMA都不会再进行转运了，此时需要DMA_Cmd，给DISABLE，关闭DMA，再为传输计数器写入一个大于0的数，再DMA_Cmd，给ENABLE，开启DMA，DMA才能继续工作，写传输计数器时，必须要先关闭DMA，再进行，不能在DMA开启时，写传输计数器。</li></ul><h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h2><ul><li>DMA（Direct Memory Access）直接存储器存取，主要是用来协助CPU，完成数据转运的工作</li><li>DMA可以提供外设（外设寄存器，一般是外设的数据寄存器DR，Data Register，比如ADC的数据寄存器，串口的数据寄存器）和存储器（运行内存（SRAM）和程序存储器（Flash）是存储变量数组和程序代码的地方）或者存储器与存储器之前的高速数据传输，无须CPU干预，节省了CPU的资源</li><li>12个独立可配置的通道（数据转运的路径）：DMA1（7个通道），DMA2（5个通道）</li><li>每个通道都支持软件触发和特定的硬件触发，存储器到存储器的数据转运，一般用软件触发，外设到存储器的转运一般用硬件触发</li><li>STM32F103C8T6 DMA资源：DMA1（7个通道）</li></ul><h2 id="DMA-基本结构"><a href="#DMA-基本结构" class="headerlink" title="DMA 基本结构"></a>DMA 基本结构</h2><p><img src="https://s2.loli.net/2024/02/28/6IkWFexsVY2Jh7Z.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/6IkWFexsVY2Jh7Z.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="DMA基本结构.png"></p><p>DMA的数据转运可以从外设到存储器，也可以是从存储器到外设，也可以从存储器转运到存储器，外设和存储器，都有3个参数，第一个是起始地址，有外设端的起始地址，和存储器端的起始地址，这两个参数决定了数据时从哪里来，到哪里去的，第二个参数是数据宽度，这个参数的作用是，指定一次转运要按多大的数据宽度来进行，可以选择字节Byte、半字节HalfWord和字Word每字节就是8位转运一个uint8_t，半字节是16位uint16_t，字是32位uint32_t</p><p>例如ADC的数据，ADC的数据是uint16_t，所以参数就要选择半字节，依次转运一个uint16_t，第三个参数是地址是否自增，这个参数的作用是，指定一次转运完成后，下一次转运，是不是要把地址移动到下一个位置去，相当于是指针p++，比如ADC扫描模式，用DMA转运数据，外设地址是ADC_DR寄存器，寄存器这边，显然地址是不用自增的，如果自增下一次转运就跑到别的寄存器那里了，存储器这边地址就需要自增，每转运一个数据后，就往后挪个坑，要不然下次再转就把上次的覆盖掉了，这就是地址是否自增的作用，就是指定是否转运一次就挪个坑。</p><p><strong>传输计数器</strong>：用来指定，总共转运几次，这个传输计数器是个自减计数器，比如写个5，那DMA就只能进行5次数据转运，转运过程中，每转运一次计数器的值就会减1，当传输计数器减到0之后，DMA就不会再进行数据转运了，减到0之后之前自增的地址，也会恢复到起始地址的位置，以方便之后DMA新一轮的转运。传输计数器的右边的自动重装器的作用就是，传输计数器减到0之后，是否要自动恢复到最初的值。比如传输计数器给5，如果不使用自动红装器，那转运5次后，DMA就结束了，如果使用自动重装器，那转运5次，计数器减到0后，就会立即重装到初始值5，自动重装器决定了转运的模式，如果不重装，就是正常的单次模式，如果重装就是循环模式，如果你想转运一个数组，那一般是单次模式，转运一轮就结束了，如果是ADC扫描模式+连续转换那为了配合ADC，DMA也需要使用循环模式，这个循环模式和ADC的连续模式差不多。</p><p>DMA的触发控制，触发就是决定DMA在什么时机进行转运的，触发源，有硬件触发，和软件触发，具体选择由M2M（Memory to Memory ）这个参数决定，当给M2M位1时，DMA就会选择软件触发，这个软件触发不是调用某个函数一次就触发一次，而是，以最快的速度，连续不断地出发DMA，指一直到传输计数器清0，软件触发和循环模式不能同时用，因为软件触发是想把传输计数器清零，循环模式是清零后自动重装，如果同时用，那DMA就停不下了，软件触发一般适用于存储器到存储器的转运，因为存储器到存储器的转运是软件启动不需要时机，当M2M位给0，那就是使用硬件触发了，硬件触发源可以选择ADC、串口、定时器等等，使用硬件触发的转运一般是与外设有关的转运，这些转运需要一定的时机，比如ADC转换完成、串口收到数据、定时时间到等等，当硬件达到这些时机时，传一个信号过来，来触发DMA进行转运。</p><p>当给DMA使能后，DMA就准备就绪，可以进行转运了。</p><h2 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h2><p><img src="https://s2.loli.net/2024/02/28/hgXTj9sH8lLPNZW.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/hgXTj9sH8lLPNZW.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="DMA请求映像.png"></p><p>此图是DMA1的请求映像，下面是DMA的7个通道，每个通道都有一个数据选择器，可以选择硬件触发和软件触发，左边的硬件触发源，每个通道的硬件触发源都是不同的，如果想选择ADC1来触发必须选择通道1，如果想选择TIM2的更新事件来触发的话，那就必须选择通道2，每个通道的硬件触发源都不同，如果想使用某个硬件触发源的话，就必须使用它所在的通道。如果使用软件触发那通道就可以任意选择。如果要使用ADC1，那就有个库函数ADC_DMACmd，必须使用这个库函数开启ADC1的这一路输出，它才有效，如果想要选择定时器2的通道3那也会有个TIM_DMACmd函数，用来进行DMA输出控制，触发源具体选择哪个，取决于你把哪个外设的DMA输出开启了，如果都开启了，那是一个或门，理论上三个硬件都可以触发，一般情况下，都是开启其中一个，<em>这7个触发源，进入到仲裁器，进行优先级判断，最终产生内部的DMA1请求，默认优先级是通道号越小，优先级越高，也可以在程序中配置优先级</em></p><h2 id="数据宽度与对齐"><a href="#数据宽度与对齐" class="headerlink" title="数据宽度与对齐"></a>数据宽度与对齐</h2><p><img src="https://s2.loli.net/2024/02/28/gI1vMeSmwLCK9Qj.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/gI1vMeSmwLCK9Qj.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据传输宽度.png"></p><ul><li><p>源端宽度 &#x3D; 目标宽度：完整转运</p></li><li><p>源端宽度 &lt; 目标宽度：高位补零</p></li><li><p>源端宽度 &gt; 目标宽度：舍弃高位</p></li></ul><p>第一列是源端宽度，第二列是目标宽度，第三列是传输数目，当源端宽度和目标宽度都是8位时，转运第一步在源端的0位置，读数据B0，在目标的0位置，写数据B0，之后就是把B1，从左边挪到右边，接着B2、B3，这是源端和目标都是8位的情况，操作也很正常，继续就是源端是8位，目标是16位，它的操作就是，在源端读B0，在目标写00B0，之后读B1写00B1，等等，意思就是<strong>如果目标宽度比源端的数据宽度大那就在目标数据前面多出来的空位补0</strong>，之后8位转运到32位，也是一样的处理，前面空出来的都补0，当<strong>目标数据宽度比源端数据宽度小时</strong>，比如由16位转到8位现象就是，读B1B0，只写入B0，读B3B2，只写入B2，把多出来的高位舍弃掉，意思就是如果你把小的数据转到大的里面，高位就会补0，如果把大的数据转到小的里面去，高位就会舍弃掉，如果数据宽度一样，那就没事。</p><h2 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h2><p><img src="https://s2.loli.net/2024/02/28/Dv465pYOhWSKy7l.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/Dv465pYOhWSKy7l.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据转运_DMA.png"></p><p>将SRAM中的数组<code>DataA</code>，转运到另一个数组<code>DataB</code>中，参数配置：外设地址是<code>DataA</code>数组的首地址，存储器地址，给<code>DataB</code>数组的首地址，数据宽度，两个数组的类型都是<code>uint8_t</code>，所以数据宽度都是按8位的字节传输，两个站点的地址都自增，转运完成后<code>DataB</code>数组的所有数据。就会等于<code>DataA</code>数组。如果左边不自增，右边自增，转运完成后，<code>DataB</code>的所有数据都会等于<code>DataA[0]</code>，如果左边自增，右边不自增，<code>DataB[0]</code>等于<code>DataA</code>的最后一个数，DataB其他的数不变，如果左右都不自增，那就是<code>DataA[0]</code>转到<code>DataB[0]</code>，其他的数据不变。方向参数，是外设站点转运到存储器站点。传输计数器给7，不需要自动重装，触发选择部分选择软件触发，最后调用<code>DMA_Cmd</code>，给DMA使能，转运7次后，传输计数器自减到0，DMA停止，转运完成，这里的数据转运是一种复制转运，转运完成后的DataA的数据并不会消失。</p><h2 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h2><p><img src="https://s2.loli.net/2024/02/28/xIu1ce4BHfMzlK8.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/xIu1ce4BHfMzlK8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ADC扫描模式_DMA.png"></p><p>左边是ADC扫描模式的转运流程，触发一次，7个通道依次进行AD转换，然后把转换结果都放在ADC_DR寄存器里面，在每个单独的通道转换完成后，进行一次DMA数据转运，并且目的地址进行自增，防止数据被覆盖，DMA的配置，外设地址，写入ADC_DR这个寄存器的地址，存储器的地址，可以在SRAM中定义一个数组ADValue然后把ADValue的地址当做存储器的地址，之后数据宽度，因为ADC_DR和SRAM数组需要uint16_t的数据，所以数据宽度都是16位的半字传输，外设地址不自增，存储器地址自增，传输方向，是外设站点到存储器站点，传输计数器和通道数一样，通道有7个，所以计数7次，计数器知否重装，看ADC的配置，ADC如果是单次扫描，那DMA的传输计数器可以不自动重装，转换一轮就停止，如果ADC是连续扫描，那DMA就可以选择使用自动重装，在ADC启动下一轮的转换的时候，DMA也启动下一轮的转运，ADC和DMA同步工作，触发选择ADC的硬件触发，ADC扫描模式在单个通道完成转换后，不会置任何标志位，也不会产生中断，但是会产生DMA请求，去触发DMA转运。一般来说DMA最常用的用途就是配合ADC的扫描模式，来解决ADC固有的缺陷，数据覆盖的问题。</p><h2 id="DMA-初始化步骤"><a href="#DMA-初始化步骤" class="headerlink" title="DMA 初始化步骤"></a>DMA 初始化步骤</h2><p>第一步，RCC开启DMA的时钟,AHB总线的设别</p><p>第二步，直接调用DMA_Init，初始化配置的参数，包括外设和存储器站点的起始地址、数据宽度、地址是否自增、方向、传输计数器、是否需要自动重装、选择触发源、通道优先级</p><p>第三步，DMA_Cmd给指定通道使能，如果使用的是硬件触发，要在对应外设调用XXX_DMACmd，开启一下触发信号的输出，需要DMA的中断，就调用DMA_ITConfig，开启中断输出，再在NVIC中配置相应的中断通道，然后写中断函数就行了，如果传输计数器清0，再想给传输计数器赋值，就DMA失能、写传输计数器、DMA使能，就可以了</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADC模数转换器简要介绍</title>
      <link href="/2024/02/28/ADC%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/02/28/ADC%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="ADC-模数转换"><a href="#ADC-模数转换" class="headerlink" title="ADC 模数转换"></a>ADC 模数转换</h1><ul><li>ADC（Analog-Digital Converter）模拟-数字转换器</li><li><strong>ADC可以将引脚上连续变换的模拟量转换成内存中储存的数字变量，建立模拟电路到数字电路的桥梁</strong>，ADC读取引脚上的模拟电压，转换为一个数据，存在寄存器里，再把这个数据读取到变量里来，就可以进行显示、判断、记录等操作</li><li>12位（分辨率，位数越高，量化结果就越精细，对应分辨率就越高）逐次逼近型ADC，1us转换时间（转换频率），</li><li><strong>输入电压范围：0-3.3V，转换结果范围：0~4095</strong>，ADC的输入电压要求在芯片的负极和正极之间变化，最低电压是负极0V，最高电压是正极3.3V，经过ADC转换之后最小值是0，最大值是4095，0V对应0,3.3V对应4095，中间都是一一对应的线性关系。</li><li>18个输入通道，<strong>可测量16个外部和2个内部信号源</strong>，外部信号源就是16个GPIO口，在引脚上直接模拟信号就行了，不需要任何的额外电路引脚就能直接测电压，2个内部信号源是内部温度传感器和内部参考电压，温度传感器可以测量CPU的温度，内部参考电压是一个1.2V左右的基准电压，这个基准电压不随外部供电电压变化而变化，如果芯片的供电不是标准的3.3V测量外部引脚的电压就可能不对，这时可以读取基准电压进行校准，这样就可以得到正确的电压值了。</li><li>规则组和注入组两个转换单元，这个是STM32 ADC的增强功能，普通AD转换流程是，启动一次转换，读一次值，然后再启动，在读值，这样的流程，但是<strong>STM32的ADC可以列一个组，连续转换多个值，一次性启动一个组，连续转换多个值，并且有两个组，一个是用于常规使用的规则组，一个是用于突发事件的注入组</strong>。</li><li>模拟看门狗自动检测输入电压范围，此ADC一般可以用于测量光线强度、温度，经常会要求光线高于某个阈值、低于某个阈值，或者温度高于某个阈值，低于某个阈值时，执行一些操作，高于某个阈值，低于某个阈值的判断，就可以用模拟看门狗来自动执行，模拟看门狗可以检测指定的某些通道，当AD值高于它设定的上阈值或者下阈值时，就会申请中断，就可以在中断函数中执行相应的操作，这样就不用手动读值，再用if判断了</li><li>STM32F103C8T6 ADC资源：ADC1、ADC2,10个外部输入通道，最多只能测量10个外部引脚的模拟信号</li></ul><h2 id="ADC-基本结构"><a href="#ADC-基本结构" class="headerlink" title="ADC 基本结构"></a>ADC 基本结构</h2><p><img src="https://s2.loli.net/2024/02/28/eIwHlLWzrXAySEo.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/eIwHlLWzrXAySEo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ADC结构.png"></p><p>左边是输入通道，16个GPIO口，外加两个内部的通道，然后输入进入AD转换器，AD转换器里有两个组，一个是规则组，一个是注入组，规则组最多可以选择16个通道，注入组最多可以选择4个通道，转换的结果有放在AD数据寄存器中，其中规则组只有1个数据寄存器，注入组有4个数据寄存器，下面是触发控制，提供开始转换的的START信号，触发控制可以选择软件触发和硬件触发，硬件触发主要是来自于定时器，当然也可以选择外部中断的引脚，右边是来自RCC的ADC时钟CLOCK，ADC逐次比较的过程就是由此时钟推动，上面可以布置一个模拟看门狗用于检测转换的结果的范围，如果超出设定的阈值，就通过中断输出控制，向NVIC申请中断，规则组和注入组在转换完成后会有个EOC信号，会置一个标志位，也可以通向NVIC，右下角是开关控制，在库函数中，就是ADC_Cmd函数，用于ADC上电的。</p><h2 id="规则组四种转换模式"><a href="#规则组四种转换模式" class="headerlink" title="规则组四种转换模式"></a>规则组四种转换模式</h2><h3 id="单次转换，非扫描模式"><a href="#单次转换，非扫描模式" class="headerlink" title="单次转换，非扫描模式"></a>单次转换，非扫描模式</h3><p><img src="https://s2.loli.net/2024/02/28/5ILQpd19DKAcCyJ.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/5ILQpd19DKAcCyJ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="单次转换非扫描模式.png"></p><p>单次转换：只转换一次，转换结束后，如果想再启动一次转换，那就需要再触发一次</p><p>非扫描：只有第一个序列1的位置有效</p><p>在非扫描模式下，这个菜单只有第一个序列1的位置有效，这时菜单同时选择一组的方式就退化成简单的选中一个的方式了，我们可以在序列1的位置指定我们想转换的通道，比如通道2，然后就可以触发转换，ADC就会对这个通道2进行模数转换，过一小段时间后，转换完成，转换结果放在数据寄存器里，同时给EOC标志位置1，整个转换过程就结束了。判断这个标志位，如果转换完了，就可以在数据寄存器中读取结果了。如果想再启动一次转换，那就需要再触发一次。转换结束，置EOC标志位，读结果。如果想换一个通道转换，那在转换之前，把第一个位置通道2改成其他通道，然后再启动转换。</p><h3 id="连续转换、非扫描模式"><a href="#连续转换、非扫描模式" class="headerlink" title="连续转换、非扫描模式"></a>连续转换、非扫描模式</h3><p><img src="https://s2.loli.net/2024/02/28/r5Bo9IpXAhNWDyi.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/r5Bo9IpXAhNWDyi.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连续转换非扫描模式.png"></p><p>连续转换：在一次转换结束后不会停止，而是立刻开始下一轮转换，然后一直持续下去，这样就只需要触发一次，之后就可以一直转换了。这个模式的好处就是，开始转换之后不需要等待一段时间，它一直都在转换，不需要手动开启转换了。也不用判断是否结束，想要读AD值的时候，就直接从数据寄存器取就行。</p><h3 id="单次转换、扫描模式"><a href="#单次转换、扫描模式" class="headerlink" title="单次转换、扫描模式"></a>单次转换、扫描模式</h3><p><img src="https://s2.loli.net/2024/02/28/HgiaxRmroNp2TlD.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/HgiaxRmroNp2TlD.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="单次转换扫描模式.png"></p><p>这个模式也是单次转换，所以每触发一次，转换结束后，就会停下来，下次转换就得再触发才能开始，他是扫描模式，这就会用到这个菜单列表了，可以在菜单里点菜，比如第一个菜是通道2，第二个菜是通道5，等等，这里每个位置是通道几可以任意指定，并且也是可以重复的，初始化结构体里还有个参数，就是通道数目，因为这16个位置可以不用完，只用前几个，那就需要再给个通道数目的参数，告诉他，我有几个通道，这里指定通道7，那它就只看前7个位置，然后每次触发之后，它就依次对前7个位置进行AD转换，转换结果都放在数据寄存器中，为了防止数据被覆盖，就需要用DMA及时将数据挪走，7个通道转换完成后，产生EOC信号，转换结束，然后再触发下一次，就又开始新一轮的转换，这就是单次转换，扫描模式的工作流程。</p><h3 id="连续转换、扫描模式"><a href="#连续转换、扫描模式" class="headerlink" title="连续转换、扫描模式"></a>连续转换、扫描模式</h3><p><img src="https://s2.loli.net/2024/02/28/JyLE8DzSgHwVPYu.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/JyLE8DzSgHwVPYu.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连续转换扫描模式.png"></p><p>在上一次模式的基础上，可以在一次转换完成后，立刻开始下一次的转换。在扫描模式的情况下，还可以右边一种模式，叫间断模式，它的作用是，在扫描的过程中，每隔几个转换，就暂停一次，需要再次触发，才能继续</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWM简要介绍</title>
      <link href="/2024/02/28/PWM%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/02/28/PWM%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="PWM简要介绍"><a href="#PWM简要介绍" class="headerlink" title="PWM简要介绍"></a>PWM简要介绍</h1><p>使用通用定时器的<em>输出比较模块</em>来输出PWM波形；<br>输出比较可以通过比较时基单元计数器(CNT)和捕获&#x2F;比较寄存器(CCR)值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形（最主要的功能）</p><h2 id="PWM的三个重要参数：频率、占空比、分辨率"><a href="#PWM的三个重要参数：频率、占空比、分辨率" class="headerlink" title="PWM的三个重要参数：频率、占空比、分辨率"></a>PWM的三个重要参数：频率、占空比、分辨率</h2><ul><li><p><strong>频率：1&#x2F;Ts；</strong> <code>Ts</code>代表一个高低电平变换周期的时间，PWM的频率越快，等效模拟信号就越平稳，同时性能开销就越大</p></li><li><p><strong>占空比：</strong> 高电平时间对于整个周期的时间比例，占空比决定了PWM等效出来的模拟电压的大小，占空比越大，等效的模拟电压就越来越趋近于高电平；占空比越小，等效的模拟电压就越来越趋近于低电平。这个等效关系一般来说时线性的，如高电平为5V，低电平为0V，50%的占空比，等效于中间电压，就是2.5V；20%占空比就等效于1&#x2F;5处的电压，就是1V。</p></li><li><p><strong>分辨率：</strong> 占空比高低的精细程度。(占空比的变化幅度)</p></li></ul><h2 id="通用定时器的输出比较模块如何输出PWM波形？"><a href="#通用定时器的输出比较模块如何输出PWM波形？" class="headerlink" title="通用定时器的输出比较模块如何输出PWM波形？"></a>通用定时器的输出比较模块如何输出PWM波形？</h2><p>通过比较<code>CCR</code>(<strong>捕获&#x2F;比较寄存器</strong>)和<code>CNT</code>(<strong>时基单元计数器</strong>)的值</p><p><img src="https://s2.loli.net/2024/02/28/lCUY3zqcbHeT5wB.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/lCUY3zqcbHeT5wB.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="pwm.png"></p><p>配置好时基单元，它的计数器<code>CNT</code>就开始不断地自增运行。在<strong>输出比较单元</strong>中与<code>CCR</code>寄存器的值不断进行比较，并根据所选择的输出比较模式输出电平<code>REF</code>；<code>REF</code>再经过极性选择和输出使能，输出到GPIO口；<code>CNT</code>的值自增达到<code>ARR</code>中设定的重装值后就重新从0开始计数（<code>REF</code>是一个频率可调，占空比也可调的PWM波形）</p><p>以PWM模式1为例子，CCR的值是30，ARR的值最高是99，当蓝色线的CNT的值小于CCR时，REF为有效电平，所以置高电平，当CNT&gt;&#x3D;CCR时，REF为无效电平，所以置低电平。然后当CNT的值达到最高值与ARR值相等（99），CNT重置为0，依次进行。得到分辨率为0.01，占空比为0.3的PWM波形</p><blockquote><p>注意：PWM占空比，当等于30的瞬间，就已经跳为低电平，0~29是高电平，总共为30个数<br>分辨率CCR的变化范围取决于AAR的值，ARR越大，CCR的范围就越大，对应的分辨率就越大。</p></blockquote><h2 id="PWM参数计算方法"><a href="#PWM参数计算方法" class="headerlink" title="PWM参数计算方法"></a>PWM参数计算方法</h2><img src="https://s2.loli.net/2024/02/28/ThwXFuRtxgLzQcs.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/ThwXFuRtxgLzQcs.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="pwm参数计算.png" style="zoom:33%;" /><ul><li>PWM<strong>频率</strong>： <code>Freq = CK_PSC / (PSC + 1) / (ARR + 1)</code> ，即时钟频率&#x2F;psc+1&#x2F;arr+1</li><li>PWM<strong>占空比</strong>： <code>Duty = CCR / (ARR + 1)</code></li><li>PWM<strong>分辨率</strong>： <code>Reso = 1 / (ARR + 1)</code></li></ul><h2 id="输出比较的8种模式"><a href="#输出比较的8种模式" class="headerlink" title="输出比较的8种模式"></a>输出比较的8种模式</h2><p><img src="https://s2.loli.net/2024/02/28/BEYnroKw39jDTM2.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/28/BEYnroKw39jDTM2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="输出比较8种模式.png"></p><p>这个模式控制器的输出是<code>CNT</code>和<code>CCR</code>的大小关系，输出是<code>REF</code>的高低电平，可以选择多种模式来更加灵活地控制<code>REF</code>输出，这个模式可以通过寄存器来进行配置。</p><h3 id="（1）-冻结"><a href="#（1）-冻结" class="headerlink" title="（1） 冻结"></a>（1） 冻结</h3><p>理解为CNT和CCR无效，REF保持为原状态</p><p>作用：假设你正在输出PWM波，暂停一段时间输出，则可以设置这个模式，一旦切换为冻结模式后，输出就可以暂停了，并且高低电平也维持为暂停时刻的状态保持不变。</p><h3 id="（2）匹配时电平翻转"><a href="#（2）匹配时电平翻转" class="headerlink" title="（2）匹配时电平翻转"></a>（2）匹配时电平翻转</h3><p>该模式可以做波形输出</p><p>这个模型可以方便地输出一个频率可调，占空比始终为50%的 PWM波形</p><p>假设设置CCR为0，那CNT每次更新清0时，就会产生一次CNT&#x3D;CCR时间，就会导致输出电平翻转一次，每更新两次为一个周期，并且高电平和低电平地时间是始终相等的，也就是占空比始终为50%，当你改变定时器更新频率时，输出波形的频率也会随之改变。</p><p><code>输出波形的频率 = 更新频率/2</code></p><h3 id="（3）CNT与CCR无效，REF强制为无效电平或者有效电平"><a href="#（3）CNT与CCR无效，REF强制为无效电平或者有效电平" class="headerlink" title="（3）CNT与CCR无效，REF强制为无效电平或者有效电平"></a>（3）CNT与CCR无效，REF强制为无效电平或者有效电平</h3><p>如果想暂停波形输出，并且在暂停时期保持低电平或者高电平，则可以设置这两个强制输出模式</p><h3 id="（4）PWM模式1、2"><a href="#（4）PWM模式1、2" class="headerlink" title="（4）PWM模式1、2"></a>（4）PWM模式1、2</h3><p>可用于输出频率和占空比都可调的PWM波形，是我们主要使用的模式</p><p>根据PWM模式1与PWM模式2的向上计数做对比，PWM模式2实际上就是PWM模式1输出取反，改变模式1与模式2，只是改变了REF电平的极性而已。</p><p>由图可知，REF输出只有还有一个极性的配置，所以使PWM模式1的正极性与PWM模式2的反极性最终的输出是一样的，输出模式里可以设置极性，最终输出也可以设置极性。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWM </tag>
            
            <tag> 输出比较模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简单总结</title>
      <link href="/2024/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2024/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简述设计模式七大原则"><a href="#简述设计模式七大原则" class="headerlink" title="简述设计模式七大原则"></a>简述设计模式七大原则</h2><p>开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。</p><p>依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。</p><p>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。</p><p>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。</p><p>迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。</p><p>合成复用原则：尽量使用组合(has-a)&#x2F;聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</p><h2 id="简述设计模式的分类"><a href="#简述设计模式的分类" class="headerlink" title="简述设计模式的分类"></a>简述设计模式的分类</h2><p>创建型模式：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="简述简单工厂模式"><a href="#简述简单工厂模式" class="headerlink" title="简述简单工厂模式"></a>简述简单工厂模式</h2><p>简单工厂模式指由一个工厂对象来创建实例,适用于工厂类负责创建对象较少的情况。例子：Spring 中的 BeanFactory 使用简单工厂模式，产生 Bean 对象。</p><h2 id="简述工厂模式"><a href="#简述工厂模式" class="headerlink" title="简述工厂模式"></a>简述工厂模式</h2><p>工厂方法模式指定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行。例子：Spring 的 FactoryBean 接口的 getObject 方法也是工厂方法。</p><h2 id="简述抽象工厂模式"><a href="#简述抽象工厂模式" class="headerlink" title="简述抽象工厂模式"></a>简述抽象工厂模式</h2><p>抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。例子：java.sql.Connection 接口。</p><h2 id="简述单例模式"><a href="#简述单例模式" class="headerlink" title="简述单例模式"></a>简述单例模式</h2><p>一个单例类在任何情况下都只存在一个实例。<br>饿汉式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> </span><br><span class="line">    Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简述代理模式"><a href="#简述代理模式" class="headerlink" title="简述代理模式"></a>简述代理模式</h2><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。</p><p>静态代理：在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p><p>动态代理：程序运行期间动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p><h2 id="简述适配器模式"><a href="#简述适配器模式" class="headerlink" title="简述适配器模式"></a>简述适配器模式</h2><p>适配器模式将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。</p><h2 id="简述模板模式"><a href="#简述模板模式" class="headerlink" title="简述模板模式"></a>简述模板模式</h2><p>模板模式定义了一个操作中的算法的骨架，并将一些步骤延迟到子类，适用于抽取子类重复代码到公共父类。<br>可以封装固定不变的部分，扩展可变的部分。但每一个不同实现都需要一个子类维护，会增加类的数量。</p><h2 id="简述装饰器模式"><a href="#简述装饰器模式" class="headerlink" title="简述装饰器模式"></a>简述装饰器模式</h2><p>装饰者模式可以动态地给对象添加一些额外的属性或行为，即需要修改原有的功能，但又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。</p><h2 id="简述观察者模式"><a href="#简述观察者模式" class="headerlink" title="简述观察者模式"></a>简述观察者模式</h2><p>观察者模式表示的是一种对象与对象之间具有依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试八股 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础知识点汇总</title>
      <link href="/2024/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2024/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是操作系统？请简要概述一下"><a href="#什么是操作系统？请简要概述一下" class="headerlink" title="什么是操作系统？请简要概述一下"></a>什么是操作系统？请简要概述一下</h2><p>操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。</p><p>向上对用户程序提供接口，向下接管硬件资源。</p><p>操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。</p><h2 id="操作系统有哪些分类？"><a href="#操作系统有哪些分类？" class="headerlink" title="操作系统有哪些分类？"></a>操作系统有哪些分类？</h2><p>操作系统常规可分为批处理操作系统、分时操作系统、实时操作系统。</p><p>若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。</p><p>常见的通用操作系统有：Windows、Linux、MacOS等。</p><h2 id="什么是内核态和用户态？"><a href="#什么是内核态和用户态？" class="headerlink" title="什么是内核态和用户态？"></a>什么是内核态和用户态？</h2><p>为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。</p><p>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</p><p>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</p><p>用户程序运行在用户态,操作系统内核运行在内核态。</p><h2 id="如何实现内核态和用户态的切换？"><a href="#如何实现内核态和用户态的切换？" class="headerlink" title="如何实现内核态和用户态的切换？"></a>如何实现内核态和用户态的切换？</h2><p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。</p><ol><li><p>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</p></li><li><p>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。</p></li><li><p>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。</p></li></ol><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><ol><li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。</p></li><li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p></li></ol><h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p><p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。</p><p>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程一般由以下的部分组成：</p><ol><li><p>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。</p></li><li><p>程序段</p></li><li><p>数据段</p></li></ol><h2 id="进程的基本操作"><a href="#进程的基本操作" class="headerlink" title="进程的基本操作"></a>进程的基本操作</h2><p>以Unix系统举例：</p><ol><li><p>进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明 确的方法来分辨程序是在父进程还是在子进程中执行。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure></li><li><p>加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br></pre></td></tr></table></figure></li><li><p>进程终止：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="简述进程间通信方法"><a href="#简述进程间通信方法" class="headerlink" title="简述进程间通信方法"></a>简述进程间通信方法</h2><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p><p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。</p><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><h2 id="进程如何通过管道进行通信"><a href="#进程如何通过管道进行通信" class="headerlink" title="进程如何通过管道进行通信"></a>进程如何通过管道进行通信</h2><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p><ol><li><p>其本质是一个伪文件(实为内核缓冲区)</p></li><li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p></li><li><p>规定数据从管道的写端流入管道，从读端流出。</p></li></ol><p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区实现。</p><p>管道的局限性：</p><ol><li><p>数据自己读不能自己写。</p></li><li><p>数据一旦被读走，便不在管道中存在，不可反复读取。</p></li><li><p>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p></li><li><p>只能在有公共祖先的进程间使用管道。</p></li></ol><h2 id="进程如何通过共享内存通信？"><a href="#进程如何通过共享内存通信？" class="headerlink" title="进程如何通过共享内存通信？"></a>进程如何通过共享内存通信？</h2><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p>特点：</p><ol><li><p>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。</p></li><li><p>因为多个进程可以同时操作，所以需要进行同步处理。</p></li><li><p>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p></li></ol><h2 id="什么是信号"><a href="#什么是信号" class="headerlink" title="什么是信号"></a>什么是信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p><ol><li><p>发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：</p><ul><li><p>内核检测到一个系统事件，比如除零错误或者子进程终止。</p></li><li><p>—个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</p></li></ul></li><li><p>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。</p></li></ol><h2 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h2><ol><li><p>处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。</p></li><li><p>在处理程序中只调用异步信号安全的函数。 所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号处理程序中断。</p></li><li><p>保存和恢复errno。 许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。</p></li><li><p>阻塞所有的信号，保护对共享全局数据结构的访问。 如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。</p></li><li><p>用volatile 声明全局变量。 考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过，因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> g;</span><br></pre></td></tr></table></figure></li><li><p>用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。</p></li><li><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。</p></li></ol><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><ol><li><p>当前运行的进程运行结束。</p></li><li><p>当前运行的进程由于某种原因阻塞。</p></li><li><p>执行完系统调用等系统程序后返回用户进程。</p></li><li><p>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</p></li><li><p>分时系统中，分给当前进程的时间片用完。</p></li></ol><h2 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h2><ol><li><p>在中断处理程序执行时。</p></li><li><p>在操作系统的内核程序临界区内。</p></li><li><p>其它需要完全屏蔽中断的原子操作过程中。</p></li></ol><h2 id="进程的调度策略"><a href="#进程的调度策略" class="headerlink" title="进程的调度策略"></a>进程的调度策略</h2><ol><li><p>先到先服务调度算法</p></li><li><p>短作业优先调度算法</p></li><li><p>优先级调度算法</p></li><li><p>时间片轮转调度算法</p></li><li><p>高响应比优先调度算法</p></li><li><p>多级队列调度算法</p></li><li><p>多级反馈队列调度算法</p></li></ol><h2 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h2><ol><li><p>CPU利用率</p></li><li><p>系统吞吐率，即单位时间内CPU完成的作业的数量。</p></li><li><p>响应时间。</p></li><li><p>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键</p><ul><li><p>平均周转时间</p></li><li><p>带权周转时间</p></li><li><p>平均带权周转时间</p></li></ul></li></ol><h2 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h2><p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。</p><ol><li>运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。</li></ol><p>2.就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。  当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p><p>3.阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</p><p>各状态之间的转换：</p><ol><li><p>就绪→执行  处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。</p></li><li><p>执行→就绪  处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。</p></li><li><p>执行→阻塞  正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。</p></li><li><p>阻塞→就绪  处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</p></li></ol><h2 id="什么是孤儿进程？僵尸进程"><a href="#什么是孤儿进程？僵尸进程" class="headerlink" title="什么是孤儿进程？僵尸进程?"></a>什么是孤儿进程？僵尸进程?</h2><ol><li>孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。</li></ol><p>2。 僵尸进程： 进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。</p><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><ol><li><p>是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。</p></li><li><p>线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</p></li><li><p>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p></li></ol><h2 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h2><p>线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p><ol><li><p>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。</p></li><li><p>进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。</p></li></ol><p>引入线程就是为了解决以上进程的不足，线程具有以下的优点：</p><ol><li><p>从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。</p></li><li><p>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。</p></li><li><p>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。</p></li></ol><h2 id="简述线程和进程的区别和联系"><a href="#简述线程和进程的区别和联系" class="headerlink" title="简述线程和进程的区别和联系"></a>简述线程和进程的区别和联系</h2><ol><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p></li><li><p>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p></li><li><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p></li><li><p>通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信<code>IPC</code>，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。</p></li><li><p>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p></li><li><p>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。</p></li><li><p>进程适应于多核、多机分布；线程适用于多核。</p></li></ol><h2 id="进程和线程的基本API"><a href="#进程和线程的基本API" class="headerlink" title="进程和线程的基本API"></a>进程和线程的基本API</h2><p>进程API以Unix系统为例，线程相关的API属于Posix线程(Pthreads)标准接口。</p><table><thead><tr><th align="center">进程原语</th><th align="center">线程原语</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>fork</code></td><td align="center"><code>pthread_create</code></td><td align="center">创建新的控制流</td></tr><tr><td align="center"><code>exit</code></td><td align="center"><code>pthread_exit</code></td><td align="center">从现有的控制流中退出</td></tr><tr><td align="center"><code>waitpid</code></td><td align="center"><code>pthread_join</code></td><td align="center">从控制流中得到退出状态</td></tr><tr><td align="center"><code>atexit</code></td><td align="center"><code>pthread_cancel_push</code></td><td align="center">注册在退出控制流时调用的函数</td></tr><tr><td align="center"><code>getpid</code></td><td align="center"><code>pthread_self</code></td><td align="center">获取控制流的ID</td></tr><tr><td align="center"><code>abort</code></td><td align="center"><code>pthread_cancel</code></td><td align="center">请求控制流的非正常退出</td></tr></tbody></table><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><ol><li><p>多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。</p></li><li><p>一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。</p></li><li><p>多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。</p></li></ol><!-- ## 线程间通信的方式1. 临界区：通过多线程的串行化来访问公共资源，速度快，适合控制数据访问。2. 互斥量`Synchronized/Lock`：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。3. 信号量`Semphare`：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。4. 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 --><h2 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h2><p>操作系统中，进程是具有不同的地址空间的，两个进程是不能感知到对方的存在的。有时候，需要多个进程来协同完成一些任务。<br>当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争的关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。<br>当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。<br>进程的同步方法：</p><ol><li><p>互斥锁</p></li><li><p>读写锁</p></li><li><p>条件变量</p></li><li><p>记录锁(record locking)</p></li><li><p>信号量</p></li><li><p>屏障（barrier）</p></li></ol><h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或是协作的线程设置同步点的问题时，需要使用一些线程同步的方法来解决这些问题。</p><p>线程同步的方法：</p><ol><li><p>互斥锁</p></li><li><p>读写锁</p></li><li><p>条件变量</p></li><li><p>信号量</p></li><li><p>自旋锁</p></li><li><p>屏障（barrier）</p></li></ol><h2 id="进程同步与线程同步有什么区别"><a href="#进程同步与线程同步有什么区别" class="headerlink" title="进程同步与线程同步有什么区别"></a>进程同步与线程同步有什么区别</h2><p>进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。</p><h2 id="死锁是怎样产生的？"><a href="#死锁是怎样产生的？" class="headerlink" title="死锁是怎样产生的？"></a>死锁是怎样产生的？</h2><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。<br>产生死锁需要满足下面四个条件：</p><ol><li><p>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。</p></li><li><p>占有并等待条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</p></li><li><p>非抢占条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。</p></li><li><p>循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。</p></li></ol><h2 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h2><p>解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下:</p><ol><li><p>资源一次性分配，这样就不会再有请求了（破坏请求条件）。</p></li><li><p>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。</p></li><li><p>可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。</p></li><li><p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p></li></ol><h2 id="什么是虚拟地址，什么是物理地址？"><a href="#什么是虚拟地址，什么是物理地址？" class="headerlink" title="什么是虚拟地址，什么是物理地址？"></a>什么是虚拟地址，什么是物理地址？</h2><p>地址空间是一个非负整数地址的有序集合。</p><p>在一个带虚拟内存的系统中，CPU 从一个有N&#x3D;pow(2,n)个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）,现代系统通常支持 32 位或者 64 位虚拟地址空间。</p><p>一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的M 个字节。</p><p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。</p><p> 一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。</p><p> 主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：</p><ol><li><p>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</p></li><li><p>它为每个进程提供了一致的地址空间，从而简化了内存管理。</p></li><li><p>它保护了每个进程的地址空间不被其他进程破坏。</p></li></ol><h2 id="为什么要引入虚拟内存？"><a href="#为什么要引入虚拟内存？" class="headerlink" title="为什么要引入虚拟内存？"></a>为什么要引入虚拟内存？</h2><ol><li><p>虚拟内存作为缓存的工具</p><ul><li>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。</li><li>虚拟内存利用DRAM缓存来自通常更大的虚拟地址空间的页面。</li></ul></li><li><p>虚拟内存作为内存管理的工具。操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。</p><ul><li><p><strong>简化链接：</strong> 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。</p><ul><li>例如：一个给定的<code>linux</code>系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址）<code>0x400000</code>开始，数据段，代码段，栈，堆等等。</li></ul></li><li><p><strong>简化加载：</strong> 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们<strong>标记为无效（未被缓存）</strong> ，将页表条目指向目标文件的起始位置。</p><ul><li><strong>加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。</strong></li></ul></li><li><p><strong>简化共享：</strong> 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。</p><ul><li><p>一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，<strong>这样OS创建页表，将虚拟页映射到不连续的物理页面。</strong></p></li><li><p>某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。<strong>OS会把不同进程中适当的虚拟页面映射到相同的物理页面。</strong></p></li></ul></li><li><p><strong>简化内存分配：</strong> 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如<code>malloc</code>），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，<strong>因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中</strong>。</p></li></ul></li></ol><ul><li>虚拟内存作为内存保护的工具。不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时，<code>MMU</code>会读一个<code>PTE</code>，通过在<code>PTE</code>上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。</li></ul><h2 id="常见的页面置换算法"><a href="#常见的页面置换算法" class="headerlink" title="常见的页面置换算法"></a>常见的页面置换算法</h2><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><ul><li><p>先进先出(FIFO)算法：</p><ul><li><p>思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。</p></li><li><p>实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p></li><li><p>特点：实现简单；性能较差，调出的页面可能是经常访问的</p></li></ul></li><li><p>最近最少使用（<code>LRU</code>）算法:</p><ul><li><p>思路： 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p></li><li><p>实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面</p></li><li><p>特点：可能达到最优的效果，维护这样的访问链表开销比较大</p></li></ul></li></ul><p>当前最常采用的就是<code>LRU</code>算法。</p><ul><li><p>最不常用算法（<code>Least Frequently Used, LFU</code>）</p><ul><li><p>思路：缺页时，置换访问次数最少的页面</p></li><li><p>实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面</p></li><li><p>特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换</p></li></ul></li></ul><h2 id="请说一下什么是写时复制？"><a href="#请说一下什么是写时复制？" class="headerlink" title="请说一下什么是写时复制？"></a>请说一下什么是写时复制？</h2><ul><li><p>如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。</p></li><li><p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p></li><li><p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p></li></ul><h2 id="实时操作系统的概念"><a href="#实时操作系统的概念" class="headerlink" title="实时操作系统的概念"></a>实时操作系统的概念</h2><p>实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</p><h2 id="优先级反转是什么？如何解决"><a href="#优先级反转是什么？如何解决" class="headerlink" title="优先级反转是什么？如何解决"></a>优先级反转是什么？如何解决</h2><p>由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务(C)而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。</p><p>目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承(priority inheritance)；另一种被称作优先级极限(priority ceilings)。</p><ol><li><p>优先级继承(priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。</p></li><li><p>优先级天花板(priority ceilings)优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 面试八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识点汇总</title>
      <link href="/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简述OSI七层协议"><a href="#简述OSI七层协议" class="headerlink" title="简述OSI七层协议"></a>简述OSI七层协议</h2><p>OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层</p><h2 id="简述TCP-IP五层协议"><a href="#简述TCP-IP五层协议" class="headerlink" title="简述TCP&#x2F;IP五层协议"></a>简述TCP&#x2F;IP五层协议</h2><p>TCP&#x2F;IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层</p><h2 id="物理层有什么作用"><a href="#物理层有什么作用" class="headerlink" title="物理层有什么作用"></a>物理层有什么作用</h2><p>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</p><h2 id="数据链路层有什么作用"><a href="#数据链路层有什么作用" class="headerlink" title="数据链路层有什么作用"></a>数据链路层有什么作用</h2><p>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</p><h2 id="网络层有什么作用"><a href="#网络层有什么作用" class="headerlink" title="网络层有什么作用"></a>网络层有什么作用</h2><p>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</p><h2 id="传输层有什么作用"><a href="#传输层有什么作用" class="headerlink" title="传输层有什么作用"></a>传输层有什么作用</h2><p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="会话层有什么作用"><a href="#会话层有什么作用" class="headerlink" title="会话层有什么作用"></a>会话层有什么作用</h2><p>建立会话：身份验证，权限鉴定等；<br>保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局；<br>断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</p><h2 id="表示层有什么作用"><a href="#表示层有什么作用" class="headerlink" title="表示层有什么作用"></a>表示层有什么作用</h2><p>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</p><h2 id="应用层有什么作用"><a href="#应用层有什么作用" class="headerlink" title="应用层有什么作用"></a>应用层有什么作用</h2><p>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</p><h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p>TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信<br>UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播</p><h2 id="为何TCP可靠"><a href="#为何TCP可靠" class="headerlink" title="为何TCP可靠"></a>为何TCP可靠</h2><p>TCP有三次握手建立连接，四次挥手关闭连接的机制。<br>除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。<br>对于每份报文也存在校验，保证每份报文可靠性。</p><h2 id="为何UDP不可靠"><a href="#为何UDP不可靠" class="headerlink" title="为何UDP不可靠"></a>为何UDP不可靠</h2><p>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。<br>仅仅在IP数据报头部加入校验和复用。<br>UDP没有服务器和客户端的概念。<br>UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</p><h2 id="简述TCP粘包现象"><a href="#简述TCP粘包现象" class="headerlink" title="简述TCP粘包现象"></a>简述TCP粘包现象</h2><p>TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。<br>可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。</p><h2 id="TCP粘包现象处理方法"><a href="#TCP粘包现象处理方法" class="headerlink" title="TCP粘包现象处理方法"></a>TCP粘包现象处理方法</h2><p>固定发送信息长度，或在两个信息之间加入分隔符。</p><h2 id="简述TCP协议的滑动窗口"><a href="#简述TCP协议的滑动窗口" class="headerlink" title="简述TCP协议的滑动窗口"></a>简述TCP协议的滑动窗口</h2><p>滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发<br>送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。</p><h2 id="简述TCP协议的拥塞控制"><a href="#简述TCP协议的拥塞控制" class="headerlink" title="简述TCP协议的拥塞控制"></a>简述TCP协议的拥塞控制</h2><p>拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.</p><p>当cwnd &lt; ssthresh 时，使用慢开始算法。<br>当cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当cwnd &#x3D; ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。</p><p>慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。</p><p>拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p><p>快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。</p><p>快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。</p><h2 id="简述快重传"><a href="#简述快重传" class="headerlink" title="简述快重传"></a>简述快重传</h2><p>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。</p><h2 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h2><ol><li>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq&#x3D;x，并将该数据包发送给服务端，客户端<br>进入syn_sent状态，等待服务端确认。</li><li>第二次握手:服务端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务端将标志位SYN和<br>ACK都置为1，ack&#x3D;x+1,随机产生一个值seq&#x3D;y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</li><li>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack&#x3D;y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输<br>数据了</li></ol><h2 id="为什么TCP握手需要三次，两次行不行？"><a href="#为什么TCP握手需要三次，两次行不行？" class="headerlink" title="为什么TCP握手需要三次，两次行不行？"></a>为什么TCP握手需要三次，两次行不行？</h2><p>不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。</p><p>如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。</p><h2 id="简述半连接队列"><a href="#简述半连接队列" class="headerlink" title="简述半连接队列"></a>简述半连接队列</h2><p>TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</p><h2 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h2><p>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</p><p>优化方式：</p><ol><li>缩短SYN Timeout时间 </li><li>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li></ol><h2 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h2><ol><li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。</li><li>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li><li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</li><li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</li></ol><h2 id="为什么TCP挥手需要4次"><a href="#为什么TCP挥手需要4次" class="headerlink" title="为什么TCP挥手需要4次"></a>为什么TCP挥手需要4次</h2><p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。</p><p>所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。</p><h2 id="为什么四次挥手释放连接时需要等待2MSL"><a href="#为什么四次挥手释放连接时需要等待2MSL" class="headerlink" title="为什么四次挥手释放连接时需要等待2MSL"></a>为什么四次挥手释放连接时需要等待2MSL</h2><p>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</p><h2 id="简述DNS协议"><a href="#简述DNS协议" class="headerlink" title="简述DNS协议"></a>简述DNS协议</h2><p>DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</p><h2 id="简述DNS解析过程"><a href="#简述DNS解析过程" class="headerlink" title="简述DNS解析过程"></a>简述DNS解析过程</h2><p>1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器</p><p>2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找</p><p>3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器</p><p>4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址</p><p>5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器</p><p>6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息</p><p>7、客户机的本地的dns服务器会将查询结果返回给我们的客户机</p><p>8、客户机根据得到的ip信息访问目标主机，完成解析过程</p><h2 id="简述HTTP协议"><a href="#简述HTTP协议" class="headerlink" title="简述HTTP协议"></a>简述HTTP协议</h2><p>http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。</p><h2 id="简述cookie"><a href="#简述cookie" class="headerlink" title="简述cookie"></a>简述cookie</h2><p>HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p><p>Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。</p><h2 id="简述session"><a href="#简述session" class="headerlink" title="简述session"></a>简述session</h2><p>session用于标记特定客户端信息，存在在服务器的一个文件里。<br>一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。</p><h2 id="简述http状态码和对应的信息"><a href="#简述http状态码和对应的信息" class="headerlink" title="简述http状态码和对应的信息"></a>简述http状态码和对应的信息</h2><p>1XX：接收的信息正在处理</p><p>2XX：请求正常处理完毕</p><p>3XX：重定向</p><p>4XX：客户端错误</p><p>5XX：服务端错误</p><p>常见错误码：<br>301：永久重定向<br>302：临时重定向<br>304：资源没修改，用之前缓存就行<br>400：客户端请求的报文有错误<br>403：表示服务器禁止访问资源<br>404：表示请求的资源在服务器上不存在或未找到</p><h2 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h2><p>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p><p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p><h2 id="简述http1-0"><a href="#简述http1-0" class="headerlink" title="简述http1.0"></a>简述http1.0</h2><p>规定了请求头和请求尾，响应头和响应尾（get post）</p><p>每一个请求都是一个单独的连接，做不到连接的复用</p><h2 id="简述http1-1的改进"><a href="#简述http1-1的改进" class="headerlink" title="简述http1.1的改进"></a>简述http1.1的改进</h2><p>HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</p><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p><p>服务端无法主动push</p><h2 id="简述HTTP短连接与长连接区别"><a href="#简述HTTP短连接与长连接区别" class="headerlink" title="简述HTTP短连接与长连接区别"></a>简述HTTP短连接与长连接区别</h2><p>HTTP中的长连接短连接指HTTP底层TCP的连接。</p><p>短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。</p><p>长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。</p><h2 id="简述http2-0的改进"><a href="#简述http2-0的改进" class="headerlink" title="简述http2.0的改进"></a>简述http2.0的改进</h2><p>提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。</p><p>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p><h2 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h2><p>http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。<br>https具有安全性的ssl加密传输协议，加密采用对称加密，<br>https协议需要到ca申请证书，一般免费证书很少，需要交费。</p><h2 id="简述TLS-SSL-HTTP-HTTPS的关系"><a href="#简述TLS-SSL-HTTP-HTTPS的关系" class="headerlink" title="简述TLS&#x2F;SSL, HTTP, HTTPS的关系"></a>简述TLS&#x2F;SSL, HTTP, HTTPS的关系</h2><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。</p><p>可以将HTTPS协议简单理解为HTTP协议＋TLS&#x2F;SSL</p><h2 id="https的连接过程"><a href="#https的连接过程" class="headerlink" title="https的连接过程"></a>https的连接过程</h2><ol><li>浏览器将支持的加密算法信息发给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器</li><li>客户端(SSL&#x2F;TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>服务器将加密后的密文发送给客户端</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成</li></ol><h2 id="Get与Post区别"><a href="#Get与Post区别" class="headerlink" title="Get与Post区别"></a>Get与Post区别</h2><p>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。</p><p>Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</p><h2 id="Get方法参数有大小限制吗"><a href="#Get方法参数有大小限制吗" class="headerlink" title="Get方法参数有大小限制吗"></a>Get方法参数有大小限制吗</h2><p>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p><h2 id="了解REST-API吗"><a href="#了解REST-API吗" class="headerlink" title="了解REST API吗"></a>了解REST API吗</h2><p>REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：</p><ul><li>Create ： POST</li><li>Read ： GET</li><li>Update ： PUT&#x2F;PATCH</li><li>Delete： DELETE</li></ul><h2 id="浏览器中输入一个网址后，具体发生了什么"><a href="#浏览器中输入一个网址后，具体发生了什么" class="headerlink" title="浏览器中输入一个网址后，具体发生了什么"></a>浏览器中输入一个网址后，具体发生了什么</h2><ol><li>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址</li><li>通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接</li><li>浏览器生成HTTP报文，发送HTTP请求，等待服务器响应</li><li>服务器处理请求，并返回给浏览器</li><li>根据HTTP是否开启长连接，进行TCP的挥手过程</li><li>浏览器根据收到的静态资源进行页面渲染</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试八股 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识点汇总</title>
      <link href="/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简述数据库三大范式"><a href="#简述数据库三大范式" class="headerlink" title="简述数据库三大范式"></a>简述数据库三大范式</h2><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p><p>数据库第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名称）中，学号-&gt;姓名，而专业编号-&gt;专业名称，不满足数据库第二范式</p><p>数据库第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即每个属性都跟主键有直接关系而不是间接关系。接着以学生表举例，对于关系模型（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范式。</p><h2 id="简述MySQL的架构"><a href="#简述MySQL的架构" class="headerlink" title="简述MySQL的架构"></a>简述MySQL的架构</h2><p>MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。</p><p>应用层：负责和客户端，响应客户端请求，建立连接，返回数据。</p><p>逻辑层：包括SQK接口，解析器，优化器，Cache与buffer。</p><p>数据库引擎层：有常见的MyISAM,InnoDB等等。</p><p>物理层：负责文件存储，日志等等。</p><h2 id="简述执行SQL语言的过程"><a href="#简述执行SQL语言的过程" class="headerlink" title="简述执行SQL语言的过程"></a>简述执行SQL语言的过程</h2><ol><li>客户端首先通过连接器进行身份认证和权限相关</li><li>如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除。</li><li>没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。</li><li>通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行。</li><li>执行语句，并从存储引擎返回数据。</li></ol><h2 id="简述MySQL的共享锁排它锁"><a href="#简述MySQL的共享锁排它锁" class="headerlink" title="简述MySQL的共享锁排它锁"></a>简述MySQL的共享锁排它锁</h2><p>共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p><h2 id="简述MySQL中的按粒度的锁分类"><a href="#简述MySQL中的按粒度的锁分类" class="headerlink" title="简述MySQL中的按粒度的锁分类"></a>简述MySQL中的按粒度的锁分类</h2><p>表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。</p><p>行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p><p>Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。</p><p>Next-key Lock： 行锁+gap锁。</p><h2 id="如何解决数据库死锁"><a href="#如何解决数据库死锁" class="headerlink" title="如何解决数据库死锁"></a>如何解决数据库死锁</h2><ol><li>预先检测到死锁的循环依赖，并立即返回一个错误。</li><li>当查询的时间达到锁等待超时的设定后放弃锁请求。</li></ol><h2 id="简述乐观锁和悲观锁"><a href="#简述乐观锁和悲观锁" class="headerlink" title="简述乐观锁和悲观锁"></a>简述乐观锁和悲观锁</h2><p>乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。</p><p>悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p><h2 id="简述InnoDB存储引擎"><a href="#简述InnoDB存储引擎" class="headerlink" title="简述InnoDB存储引擎"></a>简述InnoDB存储引擎</h2><p>InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。</p><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p><h2 id="简述MyISAM存储引擎"><a href="#简述MyISAM存储引擎" class="headerlink" title="简述MyISAM存储引擎"></a>简述MyISAM存储引擎</h2><p>MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM不支持事务，Myisam支持表级锁，不支持行级锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况</p><h2 id="简述Memory存储引擎"><a href="#简述Memory存储引擎" class="headerlink" title="简述Memory存储引擎"></a>简述Memory存储引擎</h2><p>Memory存储引擎将所有数据都保存在内存，不需要磁盘 IO。支持哈希索引，因此查找速度极快。Memory 表使用表级锁，因此并发写入的性能较低。</p><h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>索引是存储引擎中用于快速找到记录的一种数据结构。在关系型数据库中，索引具体是一种对数据库中一列或多列的值进行排序的存储结构。</p><h2 id="为什么引入索引？"><a href="#为什么引入索引？" class="headerlink" title="为什么引入索引？"></a>为什么引入索引？</h2><p>为了提高数据查询的效率。索引对数据库查询良好的性能非常关键，当表中数据量越来越大，索引对性能的影响越重要。</p><h2 id="Mysql有哪些常见索引类型？"><a href="#Mysql有哪些常见索引类型？" class="headerlink" title="Mysql有哪些常见索引类型？"></a>Mysql有哪些常见索引类型？</h2><ul><li><p>数据结构角度</p><blockquote><p>B-Tree索引<br>哈希索引<br>R-Tree索引<br>全文索引</p></blockquote></li><li><p>物理存储角度</p><blockquote><p>主键索引（聚簇索引）：叶子节点存的是整行的数据<br>非主键索引（二级索引）：叶子节点存的主键的值</p></blockquote></li></ul><h2 id="简述B-Tree与B-树"><a href="#简述B-Tree与B-树" class="headerlink" title="简述B-Tree与B+树"></a>简述B-Tree与B+树</h2><p>B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字值，且右子节点的关键字值大于或等于该节点关键字值。</p><p>B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。</p><p>B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。</p><p>B树每一个节点都包含key和value，查询效率比B+树高。</p><h2 id="简述Hash索引"><a href="#简述Hash索引" class="headerlink" title="简述Hash索引"></a>简述Hash索引</h2><p>哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。只有 Memory 引擎显式支持哈希索引。</p><p>Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找。</p><h2 id="简述自适应Hash索引"><a href="#简述自适应Hash索引" class="headerlink" title="简述自适应Hash索引"></a>简述自适应Hash索引</h2><p>InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应Hash索引。</p><h2 id="简述聚集索引和稀疏索引"><a href="#简述聚集索引和稀疏索引" class="headerlink" title="简述聚集索引和稀疏索引"></a>简述聚集索引和稀疏索引</h2><p>聚集索引按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。</p><p>稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺序搜索，直到找到所需的数据为止。</p><h2 id="简述辅助索引与回表查询"><a href="#简述辅助索引与回表查询" class="headerlink" title="简述辅助索引与回表查询"></a>简述辅助索引与回表查询</h2><p>辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。</p><p>通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查询。</p><h2 id="简述联合索引和最左匹配原则"><a href="#简述联合索引和最左匹配原则" class="headerlink" title="简述联合索引和最左匹配原则"></a>简述联合索引和最左匹配原则</h2><p>联合索引是指对表上的多个列的关键词进行索引。</p><p>对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到遇到范围查询（&gt;,&lt;,between,like）就停止匹配。Mysql会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序。</p><h2 id="简述覆盖索引"><a href="#简述覆盖索引" class="headerlink" title="简述覆盖索引"></a>简述覆盖索引</h2><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的值。</p><h2 id="为什么数据库不用红黑树用B-树"><a href="#为什么数据库不用红黑树用B-树" class="headerlink" title="为什么数据库不用红黑树用B+树"></a>为什么数据库不用红黑树用B+树</h2><p>红黑树的出度为 2，而 B Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B Tree 大非常多，IO次数很多，导致会比较慢，因此检索的次数也就更多。</p><p>B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度，IO次数较少，检索效率会更高。</p><h2 id="基于主键索引的查询和非主键索引的查询有什么区别？"><a href="#基于主键索引的查询和非主键索引的查询有什么区别？" class="headerlink" title="基于主键索引的查询和非主键索引的查询有什么区别？"></a>基于主键索引的查询和非主键索引的查询有什么区别？</h2><p>对于select * from 主键&#x3D;XX，基于主键的普通查询仅查找主键这棵树，对于select * from 非主键&#x3D;XX，基于非主键的查询有可能存在回表过程（回到主键索引树搜索的过程称为回表），因为非主键索引叶子节点仅存主键值，无整行全部信息。</p><h2 id="非主键索引的查询一定会回表吗？"><a href="#非主键索引的查询一定会回表吗？" class="headerlink" title="非主键索引的查询一定会回表吗？"></a>非主键索引的查询一定会回表吗？</h2><p>不一定，当查询语句的要求字段全部命中索引，不用回表查询。如select 主键 from 非主键&#x3D;XX，此时非主键索引叶子节点即可拿到主键信息，不用回表。</p><h2 id="简述MySQL使用EXPLAIN-的关键字段"><a href="#简述MySQL使用EXPLAIN-的关键字段" class="headerlink" title="简述MySQL使用EXPLAIN 的关键字段"></a>简述MySQL使用EXPLAIN 的关键字段</h2><p>explain关键字用于分析sql语句的执行情况，可以通过他进行sql语句的性能分析。</p><p>type：表示连接类型，从好到差的类型排序为</p><ul><li>system：系统表，数据已经加载到内存里。</li><li>const：常量连接，通过索引一次就找到。</li><li>eq_ref：唯一性索引扫描，返回所有匹配某个单独值的行。</li><li>ref：非主键非唯一索引等值扫描，const或eq_ref改为普通非唯一索引。</li><li>range：范围扫描，在索引上扫码特定范围内的值。 </li><li>index：索引树扫描，扫描索引上的全部数据。</li><li>all：全表扫描。</li></ul><p>key：显示MySQL实际决定使用的键。</p><p>key_len：显示MySQL决定使用的键长度，长度越短越好</p><p>Extra：额外信息</p><ul><li>Using filesort：MySQL使用外部的索引排序，很慢需要优化。</li><li>Using temporary：使用了临时表保存中间结果，很慢需要优化。</li><li>Using index：使用了覆盖索引。</li><li>Using where：使用了where。</li></ul><h2 id="简述MySQL优化流程"><a href="#简述MySQL优化流程" class="headerlink" title="简述MySQL优化流程"></a>简述MySQL优化流程</h2><ol><li>通过慢日志定位执行较慢的SQL语句</li><li>利用explain对这些关键字段进行分析</li><li>根据分析结果进行优化</li></ol><h2 id="简述MySQL中的日志log"><a href="#简述MySQL中的日志log" class="headerlink" title="简述MySQL中的日志log"></a>简述MySQL中的日志log</h2><p>redo log: 存储引擎级别的log（InnoDB有，MyISAM没有），该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。</p><p>undo log：是存储引擎级别的log（InnoDB有，MyISAM没有）保证数据的原子性，该log保存了事务发生之前的数据的一个版本，可以用于回滚，是MVCC的重要实现方法之一。</p><p>bin log：数据库级别的log，关注恢复数据库的数据。</p><h2 id="简述事务"><a href="#简述事务" class="headerlink" title="简述事务"></a>简述事务</h2><p>事务内的语句要么全部执行成功，要么全部执行失败。</p><p>事务满足如下几个特性：</p><ul><li><p>原子性（Atomicity）:</p><blockquote><p>一个事务中的所有操作要么全部完成，要么全部不完成。</p></blockquote></li><li><p>一致性（Consistency）:</p><blockquote><p>事务执行前后数据库的状态保存一致。</p></blockquote></li><li><p>隔离性（Isolation）</p><blockquote><p>多个并发事务对数据库进行操作，事务间互不干扰。</p></blockquote></li><li><p>持久性（Durability）</p><blockquote><p>事务执行完毕，对数据的修改是永久的，即使系统故障也不会丢失</p></blockquote></li></ul><h2 id="数据库中多个事务同时进行可能会出现什么问题？"><a href="#数据库中多个事务同时进行可能会出现什么问题？" class="headerlink" title="数据库中多个事务同时进行可能会出现什么问题？"></a>数据库中多个事务同时进行可能会出现什么问题？</h2><ul><li>丢失修改</li><li>脏读：当前事务可以查看到别的事务未提交的数据。</li><li>不可重读：在同一事务中，使用相同的查询语句，同一数据资源莫名改变了。</li><li>幻读：在同一事务中，使用相同的查询语句，莫名多出了一些之前不存在的数据，或莫名少了一些原先存在的数据。</li></ul><h2 id="SQL的事务隔离级别有哪些？"><a href="#SQL的事务隔离级别有哪些？" class="headerlink" title="SQL的事务隔离级别有哪些？"></a>SQL的事务隔离级别有哪些？</h2><ul><li><p>读未提交：</p><blockquote><p>一个事务还没提交，它做的变更就能被别的事务看到。</p></blockquote></li><li><p>读提交：</p><blockquote><p>一个事务提交后，它做的变更才能被别的事务看到。</p></blockquote></li><li><p>可重复读：</p><blockquote><p>一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到。</p></blockquote></li><li><p>串行化：</p><blockquote><p>对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行的事务完成才能继续执行。</p></blockquote></li></ul><h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p>MVCC为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰,从而实现数据库的隔离性,在事务隔离级别为读提交和可重复读中使用到。</p><p>在InnoDB中，事务在开始前会向事务系统申请一个事务ID，该ID是按申请顺序严格递增的。每行数据具有多个版本，每次事务更新数据都会生成新的数据版本，而不会直接覆盖旧的数据版本。数据的行结构中包含多个信息字段。其中实现MVCC的主要涉及最近更改该行数据的事务ID（DB_TRX_ID）和可以找到历史数据版本的指针（DB_ROLL_PTR）。InnoDB在每个事务开启瞬间会为其构造一个记录当前已经开启但未提交的事务ID的视图数组。通过比较链表中的事务ID与该行数据的值与对应的DB_TRX_ID，并通过DB_ROLL_PTR找到历史数据的值以及对应的DB_TRX_ID来决定当前版本的数据是否应该被当前事务所见。最终实现在不加锁的情况下保证数据的一致性。</p><h2 id="读提交和可重复读都基于MVCC实现，有什么区别？"><a href="#读提交和可重复读都基于MVCC实现，有什么区别？" class="headerlink" title="读提交和可重复读都基于MVCC实现，有什么区别？"></a>读提交和可重复读都基于MVCC实现，有什么区别？</h2><p>在可重复读级别下，只会在事务开始前创建视图，事务中后续的查询共用一个视图。而读提交级别下每个语句执行前都会创建新的视图。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。而对于读提交，查询能看到每个语句启动前已经提交的数据。</p><h2 id="InnoDB如何保证事务的原子性、持久性和一致性？"><a href="#InnoDB如何保证事务的原子性、持久性和一致性？" class="headerlink" title="InnoDB如何保证事务的原子性、持久性和一致性？"></a>InnoDB如何保证事务的原子性、持久性和一致性？</h2><p>利用undo log保障原子性。该log保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务原子性。</p><p>利用redo log保证事务的持久性，该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。</p><p>利用undo log+redo log保障一致性。事务中的执行需要redo log，如果执行失败，需要undo log 回滚。</p><h2 id="MySQL是如何保证主备一致的？"><a href="#MySQL是如何保证主备一致的？" class="headerlink" title="MySQL是如何保证主备一致的？"></a>MySQL是如何保证主备一致的？</h2><p>MySQL通过binlog（二进制日志）实现主备一致。binlog记录了所有修改了数据库或可能修改数据库的语句，而不会记录select、show这种不会修改数据库的语句。在备份的过程中，主库A会有一个专门的线程将主库A的binlog发送给<br>备库B进行备份。其中binlog有三种记录格式：</p><ol><li>statement:记录对数据库进行修改的语句本身，有可能会记录一些额外的相关信息。优点是binlog日志量少，IO压力小，性能较高。缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环境不同可能导致主备不一致。</li><li>row:记录对数据库做出修改的语句所影响到的数据行以及对这些行的修改。比如当修改涉及多行数据，会把涉及的每行数据都记录到binlog。优点是能够完全的还原或者复制日志被记录时的操作。缺点是日志量占用空间较大，IO压力大，性能消耗较大。</li><li>mixed:混合使用上述两种模式，一般的语句使用statment方式进行保存，如果遇到一些特殊的函数，则使用row模式进行记录。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，<br>否则就用statement格式。但是在生产环境中，一般会使用row模式。</li></ol><h2 id="redo-log与binlog的区别？"><a href="#redo-log与binlog的区别？" class="headerlink" title="redo log与binlog的区别？"></a>redo log与binlog的区别？</h2><ol><li>redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现的，会记录所有引擎对数据库的修改。</li><li>redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h2 id="crash-safe能力是什么？"><a href="#crash-safe能力是什么？" class="headerlink" title="crash-safe能力是什么？"></a>crash-safe能力是什么？</h2><p>InnoDB通过redo log保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h2 id="WAL技术是什么？"><a href="#WAL技术是什么？" class="headerlink" title="WAL技术是什么？"></a>WAL技术是什么？</h2><p>WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。事务在提交写入磁盘前，会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机I&#x2F;O访问，涉及磁盘随机I&#x2F;O访问是非常消耗时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能。</p><h2 id="两阶段提交是什么？"><a href="#两阶段提交是什么？" class="headerlink" title="两阶段提交是什么？"></a>两阶段提交是什么？</h2><p>为了保证binlog和redo log两份日志的逻辑一致，最终保证恢复到主备数据库的数据是一致的，采用两阶段提交的机制。</p><ol><li>执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作记录redo log中，此时redo log处于prepare状态。</li><li>存储引擎告知执行器执行完毕，执行器生成这个操作对应的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交commit状态，更新完成。</li></ol><h2 id="只靠binlog可以支持数据库崩溃恢复吗？"><a href="#只靠binlog可以支持数据库崩溃恢复吗？" class="headerlink" title="只靠binlog可以支持数据库崩溃恢复吗？"></a>只靠binlog可以支持数据库崩溃恢复吗？</h2><p>不可以。<br>历史原因：</p><ol><li>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那引入InnoDB原有的redo log来保证崩溃恢复能力。<br>实现原因：</li><li>binlog没有记录数据页修改的详细信息，不具备恢复数据页的能力。binlog记录着数据行的增删改，但是不记录事务对数据页的改动，这样细致的改动只记录在redo log中。当一个事务做增删改时，其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动，甚至b+tree会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到redo log中。因为数据库系统进程crash时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过程。这些信息，都是binlog中没有记录的，只记录在了存储引擎的redo log中。</li><li>操作写入binlog可细分为write和fsync两个过程，write指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘,fsync才是将数据持久化到磁盘的操作。通过参数设置sync_binlog为0的时候，表示每次提交事务都只write，不fsync。此时数据库崩溃可能导致部分提交的事务以及binlog日志由于没有持久化而丢失。</li></ol><h2 id="简述MySQL主从复制"><a href="#简述MySQL主从复制" class="headerlink" title="简述MySQL主从复制"></a>简述MySQL主从复制</h2><p>MySQL提供主从复制功能，可以方便的实现数据的多处自动备份，不仅能增加数据库的安全性，还能进行读写分离，提升数据库负载性能。</p><p>主从复制流程：</p><ol><li>在事务完成之前，主库在binlog上记录这些改变，完成binlog写入过程后，主库通知存储引擎提交事物</li><li>从库将主库的binlog复制到对应的中继日志，即开辟一个I&#x2F;O工作线程，I&#x2F;O线程在主库上打开一个普通的连接，然后开始binlog dump process，将这些事件写入中继日志。从主库的binlog中读取事件，如果已经读到最新了，线程进入睡眠并等待ma主库产生新的事件。</li></ol><p>读写分离：即只在MySQL主库上写，只在MySQL从库上读，以减少数据库压力，提高性能。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试八股 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI协议</title>
      <link href="/2024/02/27/SPI%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/02/27/SPI%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="SPI协议简述"><a href="#SPI协议简述" class="headerlink" title="SPI协议简述"></a>SPI协议简述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线</li><li>四根通信线：<ul><li>SCK（Serial Clock）提供时钟信号</li><li>MOSI（Master Output Slave Input）：在主模式下发送数据，在从模式下接收数据。</li><li>MISO（Master Input Slave Output）：在从模式下发送数据，在主模式下接收数据。</li><li>片选信号线SS（Slave Select）：它的功能是用来选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</li></ul></li><li>同步，全双工（数据发送和接收用两根线）</li><li>支持总线挂载多设备（一主多从，<strong>只能有一个主设备</strong>）</li><li>SPI所有通信线都是<strong>单端信号</strong>，它们的高低电平都是相对于GND的电压差，所以，单端信号所有的设备还需要共地；从机没有独立供电的话，主机还需要再额外引出电源正极VCC，给从机供电。</li><li>所有SPI设备的SCK、MOSI、MISO分别连在一起</li><li>主机另外引出多条SS控制线，分别接到各从机的SS引脚。主机的SS线都是输出，从机的SS线都是输入；<strong>SS线是低电平有效的</strong>，主机想指定哪个从机就把对应的SS输出线置低电平；同一时间只能选中一个从机。</li><li>输出引脚配置为<strong>推挽输出</strong>，输入引脚配置为<strong>浮空或上拉输入</strong>。推挽输出，高低电平均有很强的驱动能力，这将使得SPI引脚信号的下降沿和上升沿非常迅速。</li></ul><img src="https://s2.loli.net/2024/02/27/eSPxzq754E3jKtA.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/eSPxzq754E3jKtA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="spi基本结构.png" style="zoom: 33%;" /><h3 id="多个MISO如何避免冲突？"><a href="#多个MISO如何避免冲突？" class="headerlink" title="多个MISO如何避免冲突？"></a>多个MISO如何避免冲突？</h3><p>SPI协议规定：当从机的SS引脚为高电平（即未被选中时），它的MISO引脚必须切换为高阻态。SS为低电平时，MISO才允许变为推挽输出。</p><h2 id="基本时序"><a href="#基本时序" class="headerlink" title="基本时序"></a>基本时序</h2><ul><li><strong>起始条件</strong>：SS从高电平切换到低电平</li><li><strong>终止条件</strong>：SS从低电平切换到高电平</li><li><strong>SS线是低电平有效的</strong>，主机想指定哪个从机就把对应的SS输出线置低电平</li><li>SPI有四种采样模式，由两个配置位决定：分别为CPOL(Clock Polarity, 时钟极性)、CPHA(Clock Phase, 时钟相位)<ul><li>CPOL：规定空闲状态时钟的高低电平。<ul><li>CPOL&#x3D;0，SCK低电平为空闲状态；</li><li>CPOL&#x3D;1，SCK高电平为空闲状态</li></ul></li><li>CPHA：规定数据移入、移出的时机。<ul><li>CPHA&#x3D;0，SCK第一个边沿(上升沿)采样数据，第二个边沿(下降沿)发送数据；</li><li>CPHA&#x3D;1，SCK第一个边沿发送数据，第二个边沿采样数据</li></ul></li></ul></li></ul><blockquote><p>SPI对于一帧数据有多少位没有规定，完全取决于芯片的设定，只要符合SPI的四种采样模式和电气属性，它就属于SPI通讯</p></blockquote><h3 id="SPI发送数据过程"><a href="#SPI发送数据过程" class="headerlink" title="SPI发送数据过程"></a>SPI发送数据过程</h3><p>SPI通信的基础是<strong>交换字节</strong>。也就是说，SPI通信的过程中，通过MOSI、MISO线，主机和从机的移位寄存器会形成一个循环移位操作，每个比特的通信都是转圈的循环移位，8个时钟周期完整的交换一个字节。数据按<strong>高位在前、低位在后传输</strong>（高位先行，大端模式）。从机只有在主机发送命令时才能接收或向主机传输数据。</p><img src="https://s2.loli.net/2024/02/27/SHioN3mQaD9uzG1.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/SHioN3mQaD9uzG1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="SPI发送与接收.png" style="zoom: 50%;" /><ol><li>拉低<code>SS</code>线，表示与该设备通信</li><li>主机通过发送<code>SCK</code>时钟信号，来告诉从机写数据或者读数据。这里要注意，SCK时钟信号有效状态由时钟极性<code>CPOL</code>决定。</li><li>主机(Master)将要发送的数据写到发送数据缓存区(Menory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。</li><li>从机(Slave)也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。</li></ol><blockquote><p>SPI通信的过程中，通过MOSI、MISO线，主机和从机的移位寄存器会形成一个循环移位操作，上述过程3和过程4实际上是同时发生的。</p></blockquote><h2 id="SPI相较于IIC"><a href="#SPI相较于IIC" class="headerlink" title="SPI相较于IIC"></a>SPI相较于IIC</h2><ol><li>SPI传输更快，SPI没有规定最大传输速度，这个最大传输速度取决于芯片厂商的设计需求</li><li>设计简单，实现的功能没有I2C那么多，只支持一主多从</li><li>SPI的硬件开销比较大，通信线的个数比较多，且通信过程中，经常会有资源浪费的现象</li><li>SPI的风格：最简单最快速的完成任务,没有应答机制</li></ol><h2 id="SPI的优缺点"><a href="#SPI的优缺点" class="headerlink" title="SPI的优缺点"></a>SPI的优缺点</h2><ul><li><p><strong>优点</strong></p><ol><li>无起始位和停止位，因此数据位可以连续传输而不会被中断；</li><li>没有像I2C这样复杂的从设备寻址系统；</li><li>数据传输速率比I2C更高（几乎快两倍）；</li><li>分离的MISO和MOSI信号线，因此可以同时发送和接收数据；</li><li>极其灵活的数据传输，不限于8位，它可以是任意大小的字；</li><li>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。</li></ol></li><li><p><strong>缺点</strong></p><ol><li>使用四根信号线（I2C和UART使用两根信号线）；</li><li>无法确认是否已成功接收数据（I2C拥有此功能）；</li><li>没有任何形式的错误检查，如UART中的奇偶校验位；</li><li>只允许一个主设备；</li><li>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；</li><li>没有定义硬件级别的错误检查协议；</li><li>与RS-232和CAN总线相比，只能支持非常短的距离；</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC协议</title>
      <link href="/2024/02/27/IIC%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/02/27/IIC%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IIC协议"><a href="#IIC协议" class="headerlink" title="IIC协议"></a>IIC协议</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步，<strong>半双工</strong>（同一时间只可以单向通信）的通信协议</li><li>带数据应答，支持总线挂载多设备（一主多从、多主多从）</li><li>所有I2C设备的<code>SCL</code>连在一起，<code>SDA</code>连在一起，<code>SCL</code>由主机控制</li><li>设备的<code>SCL</code>和<code>SDA</code>均要配置成<strong>开漏输出</strong>模式（输出引脚可以将信号拉低，不能将信号拉高）</li><li><code>SCL</code>和<code>SDA</code>各添加一个上拉电阻(一般为4.7KΩ左右)</li></ul><p><img src="https://s2.loli.net/2024/02/27/JkIDrQmSXy7fEFs.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/JkIDrQmSXy7fEFs.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="iic结构.png"></p><h2 id="IIC是如何规定每个设备SCL和SDA的输入输出模式呢"><a href="#IIC是如何规定每个设备SCL和SDA的输入输出模式呢" class="headerlink" title="IIC是如何规定每个设备SCL和SDA的输入输出模式呢"></a>IIC是如何规定每个设备SCL和SDA的输入输出模式呢</h2><p>SDA线比较麻烦，因为这是半双工协议，所以主机的SDA在发送的时候是输出，在接收的时候是输入；同样，从机的SDA也会在输入和输出之间反复切换。为了避免总线没协调好导致电源短路的问题，I2C的设计是，禁止所有设备输出强上拉的高电平，采用外置弱上拉电阻加开漏输出的电路结构。以此实现总线上所有节点SDA、SCL信号的 <strong>线与</strong> 逻辑关系。</p><blockquote><p>线与：只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有设备都输出高电平，总线才处于高电平</p></blockquote><p><strong>线与</strong> 逻辑使得总线上不会出现数据冲突，实现了总线的仲裁控制。总线的控制权会交给最后一个输出低电平的设备，其它设备（输出高）通过检测总线上的电平状态（状态低），对比与自己输出状态不一致，则自动退出对总线的控制请求，从而防止了总线上的数据冲突。</p><h2 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h2><ul><li>为什么<strong>应答信号是低电平</strong>：SDA默认高电平，需要从设备主动的下拉才能输出0，因此用0做应答信号</li><li><strong>读写位</strong>：写数据为0，读数据为1，传输数据时高位先行</li><li>发送和接收都是先拉低SCL线，然后将数据放到SDA上，再放手让SCL回弹到高电平。在高电平期间读取放到SDA上的数据</li><li><strong>空闲状态</strong>：时钟线（SCL）和数据线（SDA）接上拉电阻，<strong>默认高电平</strong>，表示总线是空闲状态</li><li><strong>起始条件</strong>：<code>SCL</code>高电平期间，<code>SDA</code>从高电平切换到低电平</li><li><strong>终止条件</strong>：<code>SCL</code>高电平期间，<code>SDA</code>从低电平切换到高电平</li><li>每个时序单元的<code>SCL</code>都是以低电平开始，低电平结束</li><li>从机不允许产生起始和终止</li><li>数据的先后顺序为：<strong>高位在前</strong></li></ul><h3 id="如何保证数据有效？"><a href="#如何保证数据有效？" class="headerlink" title="如何保证数据有效？"></a>如何保证数据有效？</h3><p>I2C总线进行数据传送时，在SCL的每个时钟脉冲期间传输一个数据位，<strong>时钟信号SCL为高电平期间，数据线SDA上的数据必须保持稳定</strong>，只有在时钟线SCL上的信号为低电平期间，数据线SDA上的高电平或低电平状态才允许变化，因为当SCL是高电平时，数据线SDA的变化被规定为<strong>控制命令</strong>（<strong>START</strong>或<strong>STOP</strong>，也就是前面的<strong>起始信号</strong>和<strong>停止信号</strong>）。</p><img src="https://s2.loli.net/2024/02/27/SyTQ4evBuDfGVNa.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/SyTQ4evBuDfGVNa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IIC数据稳定.png" style="zoom:67%;" /><h3 id="I2C写时序"><a href="#I2C写时序" class="headerlink" title="I2C写时序"></a>I2C写时序</h3><ol><li>主机发起开始信号</li><li>发送 从机设备地址，高七位是设备地址，最后一位是读写位 （这里是写信号0）</li><li>从机发送应答信号 </li><li>主机发送8位从机寄存器地址 </li><li>从机发送应答信号 </li><li>发送要写入寄存器的数据(<strong>高位先行</strong>，一个字节) </li><li>从机发送应答信号 </li><li>主机发送停止信号</li></ol><p><img src="https://s2.loli.net/2024/02/27/r2xajbmv4l8sFYd.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/r2xajbmv4l8sFYd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IIC写时序.png"></p><h3 id="I2C读时序"><a href="#I2C读时序" class="headerlink" title="I2C读时序"></a>I2C读时序</h3><ol><li>主机发送开始信号</li><li>主机发送从机地址，最后一位是写信号(0)</li><li>从机发送应答信号 </li><li>主机发送要读取数据的从机寄存器地址 </li><li>从机发送应答信号</li><li>主机重新发送开始信号 （主机将由发送变为接收，从机将由接收变为发送)）</li><li>主机发送从机设备地址，最后一位是读信号(1) </li><li>从机产生应答信号 </li><li>主机读取一个字节的数据 </li><li>主机产生一个非应答信号 ，表示不再接收数据</li><li>主机发送停止信号</li></ol><img src="https://s2.loli.net/2024/02/27/TaFiDQW8gRp2tVX.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/TaFiDQW8gRp2tVX.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IIC读时序.png" style="zoom: 50%;" /><h2 id="IIC缺点"><a href="#IIC缺点" class="headerlink" title="IIC缺点"></a>IIC缺点</h2><p>由于I2C开漏外加上拉电阻的电路结构，使得通信线高电平的驱动能力比较弱，这就会导致通信线由低电平变到高电平的时候，上升沿耗时较长，限制了I2C的最大通信速度。所以I2C的标准模式只有100KHz的时钟频率，快速模式也只有400KHZ。</p><h2 id="IIC优点"><a href="#IIC优点" class="headerlink" title="IIC优点"></a>IIC优点</h2><p>在消耗最低硬件资源的情况下，实现最多的功能。在硬件上，无论挂载多少个设备，都只需要两根通信线。在软件上，数据双向通信，应答位，都可以实现。</p><h2 id="硬件IIC与软件IIC的区别"><a href="#硬件IIC与软件IIC的区别" class="headerlink" title="硬件IIC与软件IIC的区别"></a>硬件IIC与软件IIC的区别</h2><h4 id="软件IIC："><a href="#软件IIC：" class="headerlink" title="软件IIC："></a>软件IIC：</h4><p>软件IIC通信指的是用单片机的两个I&#x2F;O端口模拟出来的IIC，用软件控制管脚状态以模拟I2C通信波形，软件模拟寄存器的工作方式。因为软件模拟的整个流程比较清晰，哪里出来bug，很快能找到问题。</p><blockquote><p>软件I2C由于不受管脚限制，接口比较灵活</p></blockquote><h4 id="硬件IIC"><a href="#硬件IIC" class="headerlink" title="硬件IIC"></a>硬件IIC</h4><p>一块硬件电路，硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的，硬件（固件）I2C是直接调用内部寄存器进行配置。写代码会相对简单，<strong>只要调用I2C的控制函数即可</strong>，<strong>不需要用代码去控制SCL、SDA的各种高低电平变化来实现I2C协议</strong>，只需要将I2C协议中的可变部分（如：从设备地址、传输数据等等）通过函数传参给控制器，控制器自动按照I2C协议实现传输，但是如果出现问题，就只能通过示波器看波形找问题。</p><blockquote><p>硬件I2C的效率要远高于软件的</p></blockquote><blockquote><p>这里要注意IIC是为了与低速设备通信而发明的，所以IIC的传输速率比不上SPI</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> IIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART协议</title>
      <link href="/2024/02/27/UART%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/02/27/UART%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><p><strong>一句话总结串口通信</strong>：</p><p>UART是一种<strong>串行、异步、全双工的通信协议</strong>。<code>TX</code>引脚输出定时反转的高低电平，<code>RX</code>引脚定时读取引脚的高低电平，每个字节的数据加上起始位、停止位、可选的校验位，打包成数据帧，依次输出在<code>TX</code>引脚，另一端<code>RX</code>引脚依次接收。</p><img src="https://s2.loli.net/2024/02/27/k6MOpK8XtQFyuvh.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/k6MOpK8XtQFyuvh.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="uart示意图.png" style="zoom: 33%;" /><blockquote><p>UART接口不使用时钟信号来同步发送器和接收器设备，而是以异步方式传输数据。发送器根据其时钟信号生成的位流取代了时钟信号，接收器使用其内部时钟信号对输入数据进行采样。同步点是通过两个设备的<strong>相同波特率</strong>来管理的。如果波特率不同，发送和接收数据的时序可能会受影响，导致数据处理过程出现不一致。允许的波特率差异最大值为10%，超过此值，位的时序就会脱节。</p></blockquote><h2 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h2><p>电平标准是数据<code>1</code>和数据<code>0</code>的表达方式，是人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p><ul><li><strong>TTL电平</strong>：+3.3V或+5V表示1，0V表示0</li><li><strong>RS232电平</strong>：-3<del>-15V表示1，+3</del>+15V表示0</li><li><strong>RS485电平</strong>：两线压差+2<del>+6V表示1，-2</del>-6V表示0（差分信号）</li></ul><h2 id="波特率：规定了串口通信的速率"><a href="#波特率：规定了串口通信的速率" class="headerlink" title="波特率：规定了串口通信的速率"></a>波特率：规定了串口通信的速率</h2><p>波特率规定串口通信的速率（串口一般使用异步通信，需要双方约定一个通信速率），例如每隔1s发送一位，接收方也要每隔1s接收一位，接收快了，就会重复接收某些位，如果接收慢了，就会漏掉某些位，发送和接收必须约定好速率，波特率本义是<em>每秒传输码元的个数</em>，单位是<em>码元&#x2F;s</em>，或者直接叫<strong>波特(Baud)<strong>，</strong>比特率是每秒传输的比特数</strong>，单位是<code>bit/s</code>，或者叫<code>bps</code>，<strong>在二进制调制的情况下，一个码元就是一个bit</strong>，此时波特率就等于比特率，单片机的串口通信，基本都是二进制调制，也就是高电平表示1，低电平表示0，一位就是1bit，规定波特率为1000bps，表示1s要发1000位，每一位的时间就是1ms，发送方每隔1ms发送一位，接收方每隔1ms接收一位，</p><h2 id="串口数据帧的整体结构"><a href="#串口数据帧的整体结构" class="headerlink" title="串口数据帧的整体结构"></a>串口数据帧的整体结构</h2><p>串口中，每一个字节都装载在一个数据帧里面，每个数据帧都由<strong>起始位、数据位和停止位</strong>组成，数据位有8个，代表一个字节的8位，还可以在数据位的最后加一个<strong>奇偶校验位</strong>，这样数据位总共就是9位，其中有效载荷是前8位，代表1个字节，校验位跟在有效载荷后面，占1位<br><img src="https://s2.loli.net/2024/02/27/e1z7tGMQkvCSbhJ.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/e1z7tGMQkvCSbhJ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="uart数据帧.png"></p><h3 id="起始位"><a href="#起始位" class="headerlink" title="起始位"></a>起始位</h3><p>标志一个数据帧的开始，固定为<strong>低电平</strong>。（串口的空闲状态是高电平，没有数据传输的时候引脚必须置高电平，作为空闲状态）需要传输的时候先发送一个起始位，起始位必须是低电平，产生一个下降沿（告诉接受设备，这一帧数据要开始了），表示传输开始</p><h3 id="停止位"><a href="#停止位" class="headerlink" title="停止位"></a>停止位</h3><p>标志一个数据帧的结束，固定为<strong>高电平</strong>。在一个字节数据发送完成后，必须要有一个停止位，这个停止位的作用是，用于数据帧间隔，固定为高电平，同时这个停止位也是为下一个起始位做准备的，如果没有停止位，那当为数据最后一位是<code>0</code>的时候，下次再发送新的一帧，就没法产生下降沿了—–停止位把引脚恢复成高电平，方便下一次的下降沿，如果没有数据了，引脚也为高电平，代表空闲状态</p><h3 id="数据位"><a href="#数据位" class="headerlink" title="数据位"></a>数据位</h3><p>表示数据帧的有效载荷，1为高电平，0位低电平，<strong>低位先行</strong></p><p>有两种表示方法，一种是把校验位作为数据位的一部分，另一种就是把校验位和数据位独立开.<br>数据位就是有效载荷，校验位就是独立的1位，在串口助手里就是选择的把数据位和校验位分开描述的方法，总之无论是合在一起，还是分开描述，描述的都是同一个东西</p><p>低位先行的意思是，如果你要发送一个<code>0x0F</code>，二进制为<code>00001111</code>，发送时低位先行也就是按<code>11110000</code>的顺序发送</p><h3 id="校验位"><a href="#校验位" class="headerlink" title="校验位"></a>校验位</h3><p>串口使用<strong>奇偶校验位</strong>方法，这里奇偶指的是数据帧中<em>1的个数</em></p><ul><li>奇校验：1的个数为奇数；</li><li>偶校验：1的个数为偶数</li></ul><p>如果使用了奇校验，那么<strong>包括校验位在内</strong>的9位数据会出现奇数个1，如果传输 <code>0000 1111</code>，目前总共4个1，是偶数个，那么校验位就需要再补一个1，连同校验位就是<code>0000 1111 1</code>，总共5个1，保证1的个数为奇数，如果数据是<code>0000 1110</code>，此时3个1，是奇数个，那么校验位就补1个0，连同校验位就是<code>0000 1110 0</code>，发送方，在发送数据后，会补一个校验位，保证1的个数为奇数，接收方在接收数据后，会验证数据位和校验位，如果1的个数还是奇数，就认为数据没有出错。</p><p>但是奇偶校验的检出率不是很高，例如，如果有两位数据同时出错，就特性不变，那就校验不出来了，就能校验只能保证一定程度上的数据校验，如果想要更高的检出率可以选择CRC校验，STM32内部也有CRC外设。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UART </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法详解</title>
      <link href="/2024/02/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/02/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h1><p>基于比较：冒泡排序，选择排序，插入排序</p><p>分治思想：希尔排序，归并排序，快速排序</p><p>数据结构：堆排序</p><p>基于计数：计数排序，桶排序，基数排序</p><h2 id="时间复杂度及稳定性"><a href="#时间复杂度及稳定性" class="headerlink" title="时间复杂度及稳定性"></a>时间复杂度及稳定性</h2><p><img src="https://s2.loli.net/2024/02/27/pHqKkVNztsU3cQi.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/02/27/pHqKkVNztsU3cQi.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="排序总结"></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序每次只对 相邻 两个元素进行操作，每次冒泡操作，都会 比较 相邻两个元素的大小，若不满足排序要求，就将他们交换，每一次冒泡，都会将一个元素移动到它应该在的位置，该元素就是 未排序元素中 最大的元素</p><ul><li>第一次冒泡图解：</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_60e2ceb471-7.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_60e2ceb471-7.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="一次冒泡" style="zoom:67%;" /><ul><li>整个冒泡排序过程：</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_6452e26471-8.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_6452e26471-8.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="冒泡排序" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> length = array.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length-i<span class="number">-1</span>;j++)</span><br><span class="line"><span class="comment">// 递增 increase</span></span><br><span class="line"><span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line"><span class="built_in">swap</span>(array[j], array[j+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 递减 decrease</span></span><br><span class="line"><span class="comment">//if(array[j] &lt; array[j+1])</span></span><br><span class="line"><span class="comment">//swap(array[j], array[j+1]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好情况:</strong> 我们只需要进行一次冒泡操作，没有任何元素发生交换，此时就可以结束程序，所以最好情况时间复杂度是<code>O(n)</code>.</p><p><strong>最坏情况:</strong> 要排序的数据完全倒序排列的，我们需要进行n次冒泡操作，每次冒泡时间复杂度为<code>O(n)</code>,所以最坏情况时间复杂度为<code>O(n^2)</code>。</p><p><strong>是否稳定：</strong> 在冒泡排序的过程中，只有每一次冒泡操作才会交换两个元素的顺序。所以我们为了冒泡排序的稳定性，在元素相等的情况下，我们不予交换，此时冒泡排序即为<strong>稳定的</strong>排序算法。</p><h2 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h2><p>设置一个标志位，而是如果已经是有序的(内层循环未进行交换)，就不再遍历，直接就跳出循环了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort_OPT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> length = array.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">swap</span>(array[j], array[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>首先我们将数组中的数据分为两个区间，一个是已排序区间，另一个是未排序区间，同时这两个区间都是动态的。开始时，假设最左侧的元素已被排序，即为已排序区间，每一次将未排序区间的首个数据放入排序好的区间中，直到未排序空间为空。</p><ul><li>插入排序算法图解：</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_52d123e871-4.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_52d123e871-4.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="插入排序" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> length = array.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line"><span class="type">int</span> key = array[i];</span><br><span class="line"><span class="type">int</span> j = i<span class="number">-1</span>;  <span class="comment">// [0,j] 已排序区间</span></span><br><span class="line"><span class="keyword">while</span>((j&gt;=<span class="number">0</span>)&amp;&amp;(array[j]&gt;key))&#123;</span><br><span class="line">array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">array[j+<span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好情况</strong>: 即该数据已经有序，我们不需要移动任何元素。于是我们需要从头到尾遍历整个数组中的元素<code>O(n)</code>.</p><p><strong>最坏情况:</strong> 即数组中的元素刚好是倒序的，每次插入时都需要和已排序区间中所有元素进行比较，并移动元素。因此最坏情况下的时间复杂度是<code>O(n^2)</code>.</p><p><strong>平均时间复杂度:</strong> 类似我们在一个数组中插入一个元素那样，该算法的平均时间复杂度为<code>O(n^2)</code>.</p><p><strong>是否稳定：</strong> 我们在插入的过程中，如果遇到相同的元素，我们可以选择将其插入到之前元素的前面也可以选择插入到后面。所以，插入排序可以是稳定的也可能是不稳定的。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序和插入排序类似，也将数组分为<code>已排序</code>和<code>未排序</code>两个区间。但是在选择排序的实现过程中，不会发生元素的<code>移动</code>，而是直接进行<code>元素的交换</code>。</p><p>选择排序的实现过程: 不断在<code>未排序</code>的区间中找到最小&#x2F;最大的元素，将其放入<code>已排序</code>区间的尾部。</p><ul><li>选择排序图解</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_572fd11471-5.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_572fd11471-5.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="选择排序" style="zoom:67%;" /><ul><li>选择排序代码实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> length = array.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line"><span class="keyword">if</span>(array[j]&lt;array[minIndex]) minIndex = j;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(array[i], array[minIndex]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好情况，最坏情况：</strong> 都需要遍历未排序区间，找到最小元素。所以都为<code>O(n^2).</code>.</p><p><strong>平均复杂度</strong>：都为<code>O(n^2)</code>.</p><p><strong>是否稳定：</strong> 不稳定，因为每次都要在未排序区间找到最小的值和前面的元素进行交换，这样如果遇到相同的元素，会使他们的顺序发生交换。</p><h1 id="※※※-归并排序（重要）※※※"><a href="#※※※-归并排序（重要）※※※" class="headerlink" title="※※※ 归并排序（重要）※※※"></a>※※※ 归并排序（重要）※※※</h1><p>该算法是利用<strong>分治思想</strong>解决问题的一个非常典型的应用。归并排序的基本思路就是先把数组一分为二，然后分别把左右数组排好序，再将排好序的左右两个数组合并成一个新的数组，最后整个数组就是有序的了</p><ul><li>归并排序图解：</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_891b9cb271-10.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_891b9cb271-10.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="归并排序" style="zoom:67%;" /><p>递归实现版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(right-left+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[i] &lt; array[j])</span><br><span class="line">tmp[k++] = array[i++];</span><br><span class="line"><span class="keyword">else</span> tmp[k++] = array[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">tmp[k++] = array[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">tmp[k++] = array[j++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; right-left+<span class="number">1</span>; m++)</span><br><span class="line">array[left + m] = tmp[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//int mid = (left + right) / 2;</span></span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 可以避免溢出</span></span><br><span class="line"><span class="built_in">MergeSort</span>(array, left, mid);</span><br><span class="line"><span class="built_in">MergeSort</span>(array, mid+<span class="number">1</span>, right);</span><br><span class="line"><span class="built_in">Merge</span>(array, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中需要用到两个函数，一个是<code>MergeSort</code>函数，一个是<code>Merge</code>函数。<code>MergeSort</code>函数的作用是把数组中left至right的元素全部排列好。而<code>Merge</code>函数的作用是把左右两个已经排序好的数组合并成一个数组。</p><p><code>Merge</code>函数的编写非常重要，首先我们需要创建一个新的数组<code>temp</code>，数组大小为<code>right-left+1</code>.然后定义两个下标i和j, 其中<code>i=left, j=mid+1</code>,<code>i</code>表示第一个数组的起始位置，<code>j</code>表示第二个数组的起始位置。同时还需要一个下标<code>k</code>来标记<code>temp</code>数组中填入元素的位置。</p><p>接下来开始遍历两个数组，比较<code>i</code>和<code>j</code>所指元素的大小，将较小者放入<code>temp</code>数组中，同时该较小者下标和<code>k</code>向后移动。当其中一个子数组循环完后，将剩下数组中的元素依次放入<code>temp</code>数组中。</p><p>最终，将<code>temp</code>中已排序好的数组拷贝回原数组<code>array</code>，再返回经过归并排序好的数组。</p><p><code>MeergeSort</code>函数主要是用于递归调用。当<code>right &gt;= left</code>时，就直接<code>return</code>。否则，找到数组的中间下标，将数组一分为二，分别两边两边数组进行归并排序，最后将两个数组用<code>Merge</code>函数合并起来。</p><ul><li>迭代实现版本：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort_it</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;  <span class="comment">// 存储归并排序结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;    <span class="comment">// seg为当前归并的子数组长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> beg = <span class="number">0</span>; beg &lt; len; beg += seg + seg) &#123;  <span class="comment">// beg为当前子数组的起始位置</span></span><br><span class="line"><span class="type">int</span> low = beg;  <span class="comment">// 子数组的低位索引</span></span><br><span class="line"><span class="type">int</span> mid = <span class="built_in">min</span>(beg + seg, len);  <span class="comment">// 子数组的中间位置索引（最大为len）</span></span><br><span class="line"><span class="type">int</span> high = <span class="built_in">min</span>(beg + seg + seg, len);  <span class="comment">// 子数组的高位索引（最大为len）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = low;  <span class="comment">// 左侧子数组的起始索引</span></span><br><span class="line"><span class="type">int</span> j = mid;  <span class="comment">// 右侧子数组的起始索引</span></span><br><span class="line"><span class="type">int</span> k = low;  <span class="comment">// 临时数组ans的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在左右子数组中进行归并排序</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; high) &#123;</span><br><span class="line"><span class="comment">// 选择左右子数组中较小的元素放入临时数组ans中</span></span><br><span class="line">ans[k++] = array[i] &gt; array[j] ? array[j++] : array[i++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余的元素放入临时数组ans中</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line">ans[k++] = array[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">ans[k++] = array[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将临时数组ans中的排序结果拷贝回原始数组arr中</span></span><br><span class="line"><span class="keyword">for</span> (k = beg; k &lt; high; ++k) &#123;</span><br><span class="line">array[k] = ans[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的递推公式为<code>T(n)=2*T(n/2)+n</code></p><p>该递归式表明，对n个元素递归排序所需时间复杂度，等于左右子区间<code>n/2</code>个元素分别递归排序的时间，加上将两个已排好的子区间合并起来的时间<code>O(n)</code></p><p>当递归循环至最后一层时，即<code>n=1</code>时,<code>T(1)=1</code>,于是可以推导出<strong>归并排序的时间复杂度</strong>为<code>O(nlongn)</code></p><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_8d3c931e71-11.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_8d3c931e71-11.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom:67%;" /><p><strong>是否稳定：</strong> 稳定。当我们遇到左右数组中的元素相同时，我们可以先把左边的元素放入temp数组中，再放入右边数组的元素，这样就保证了相同元素的前后顺序不发生改变。所以，归并排序是一个稳定的排序算法。</p><h1 id="※※※-快速排序（重要）※※※"><a href="#※※※-快速排序（重要）※※※" class="headerlink" title="※※※ 快速排序（重要）※※※"></a>※※※ 快速排序（重要）※※※</h1><p>快速排序，也就是我们常说的“快排”。其实，快排也是利用的分治思想。它具体的做法是在数组中取一个基准<code>pivot</code>，<code>pivot</code>位置可以随机选择(一般我们选择数组中的最后一个元素)。选择完<code>pivot</code>之后，将小于<code>pivot</code>的所有元素放在<code>pivot</code>左边，将大于<code>pivot</code>的所有元素放在右边。最终，<code>pivot</code>左侧元素都将小于右侧元素。接下来我们递归将左侧的子数组和右侧子数组进行快速排序。如果左右两侧的数组都是有序的话，那么我们的整个数组就处于有序的状态了。</p><p><strong>快速排序的主要步骤为：</strong></p><ol><li>挑选<code>基准值</code>：从数组中挑出一个元素，称为“基准”（pivot）</li><li><code>分割</code>：重新排序数组，所有比<code>pivot</code>小的元素摆放在<code>pivot</code>前面，所有比<code>pivot</code>值大的元素放在<code>pivot</code>后面(与<code>pivot</code>值相等的数可以到任何一边)。</li><li><code>递归</code>排序子数组：递归地将小于<code>pivot</code>元素的子序列和大于<code>pivot</code>元素的子序列进行快速排序。</li><li>递归到最底部的判断条件是数列的大小是<code>零或一</code>，此时该数列显然已经有序。</li></ol><ul><li>快速排序图解</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_908dbade71-12.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_908dbade71-12.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="快速排序" style="zoom:67%;" /><ul><li>代码实现：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pivot = right;</span><br><span class="line"><span class="type">int</span> location = left;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[i] &lt; array[pivot])&#123;</span><br><span class="line"><span class="built_in">swap</span>(array[i], array[location]);</span><br><span class="line">location++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(array[pivot], array[location]);</span><br><span class="line"><span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> pivot = <span class="built_in">partition</span>(array, left, right);</span><br><span class="line"><span class="built_in">QuickSort</span>(array, left, pivot<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(array, pivot+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序算法中有两个函数,<code>QuickSort</code>函数和<code>partition</code>函数。<code>partition</code>函数的作用返回<code>pivot</code>下标，意思是此时，所有在<code>pivot</code>左侧的元素都比<code>pivot</code>的值小，在右侧的值比<code>pivot</code>大。接下来对左右两侧的数组递归调用<code>QuickSort</code>函数进行快排。</p><p>我们每次指定<code>pivot</code>指向最后一个元素，同时定义一个变量<code>location</code>，用来标记<code>pivot</code>最后应该置于的位置。在<code>location</code>左侧的所有元素都是比<code>pivot</code>值小的，从<code>location</code>开始，右侧所有元素都比<code>pivot</code>大。</p><p>只要遍历到的元素比<code>pivot</code>的值小，就与<code>location</code>所指的元素进行交换，同时<code>location++</code>，更新<code>pivot</code>应该在的位置。</p><p>数组遍历结束，最后将元素<code>pivot</code>与<code>location</code>所指元素进行交换，这样，<code>pivot</code>左侧的元素就全部比<code>pivot</code>小，右侧元素全部比pivot大了。</p><p><strong>时间复杂度：</strong> 快排的时间复杂度也可以像归并排序那样用递推公式计算出来。如果每次分区都刚好把数组分成两个大小一样的区间，那么它的时间复杂度也为<code>O(nlogn)</code>.但是如果遇到最坏情况下，该算法可能退化成<code>O(n^2)</code>.</p><p><strong>是否稳定：</strong> 因为分区操作涉及元素之间的交换，当遍历到第一个小于2的元素1时，会交换1与前面的3，因此两个相等3的顺序就发生了改变。所以快速排序不是一个稳定的排序算法。</p><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_93cd488671-13.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_93cd488671-13.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom:67%;" /><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为<code>键</code>存储在<code>额外开辟</code>的数组空间中。简单点说，就是用额外的数组记录输入数据中各数据出现的<code>次数</code>，然后将数据按出现<code>频数</code>取出。</p><ul><li>计数排序实现步骤：</li></ul><p>计数排序思路比较简单，先找到数组中元素最大值<code>max</code>,额外分配一个大小为<code>max+1</code>的数组用于计算元素出现次数。最后从小到大按元素个数更新原数组。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_96f5691c71-14.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_96f5691c71-14.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计数排序"></p><ul><li>代码实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:array)</span><br><span class="line"><span class="keyword">if</span>(x &gt; max) max = x;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(max+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)</span><br><span class="line">counter[array[i]]++;</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;counter.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> cnt=<span class="number">0</span>; cnt&lt;counter[k];cnt++)</span><br><span class="line">array[index++] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法优化</strong></p><p>从上面的图中可以看到，我们在计数时分配了计数数组count，但是count数组的两个位置根本没有计入任何数字。那是因为该数组中最小的元素为2，不可能存在0和1了。因此我们可以对我们之前的代码进行改进，找到数组中的最大元素和最小元素，然后分配max-min+1空间的数组即可。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆是一棵<strong>完全二叉树</strong>。堆中的任意节点的值都必须<strong>大于等于或小于等于</strong>它的子节点；</p><p>其中，将每个节点的值都大于等于其子节点值的堆称为“<strong>大顶堆</strong>”(max heap)，将每个节点的值小于等于子节点值的堆称为“<strong>小顶堆</strong>”(min heap)</p><p>我们常用<strong>数组</strong>来存储堆：对于堆中元素下标为<code>i</code>的点：</p><p><code>2*i+1</code>为它的左子节点；<code>2*i+2</code>为它的右子节点；<code>i/2</code>是它的前继节点</p><p><strong>维护堆：</strong>对于“大顶堆”，修改思路是将待维护节点与子节点相比较，如果它的值小于它的子节点，就将其与子节点中最大值发生交换，然后继续对该点进行判断，直到到达合适的地方。</p><p><strong>建堆</strong>：当我们需要维护一个大小为<code>n</code>的堆时，一般从下标<code>n/2</code>的位置不断向前移动调整。</p><p><strong>大顶堆排序思路：</strong>根据“大顶堆”的定义，堆顶元素即为整个数据中的最大值。于是当我们建好堆后，我们将堆顶元素与堆中最后一个元素交换，将堆中最大元素放在了数组中的最后一个位置。此时，因为我们将较小的元素放在了堆顶，所以我们需要对其进行堆维护。维护完成后，堆顶元素为此时堆中的最大元素，然后继续重复上面的操作，反向填充数组，直到最后堆中剩下一个元素，即在数组的首位置。</p><blockquote><p>注意：利用大顶堆进行堆排序得到的是递增序列，小顶堆得到递减序列</p></blockquote><ul><li>堆排序图解</li></ul><img src="https://cdn.acwing.com/media/article/image/2020/03/29/32343_c6b11de071-27.jpg" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2020/03/29/32343_c6b11de071-27.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">40</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">24</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">36</span> &#125;;</span><br><span class="line">    <span class="built_in">heapSort</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : arr) </span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待调整堆；需要维护堆的大小；需要调整的节点索引</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);   <span class="comment">//堆的数量减一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含<code>n</code>个元素的完整二叉树的高度为<code>logn</code>，最坏情况下，我们需要将元素从根移动到叶子节点，进行多次<code>logn</code>的比较和交换。在建堆阶段，我们对<code>n/2</code>元素执行此操作，因此建堆步骤的最坏情况复杂度为<code>n/2*log(n) ~ nlogn</code>。在排序步骤中，我们将根元素与最后一个元素交换，并堆放根元素。对于每个元素，这又需要花费<code>logn</code>最长时间，因为我们可能需要将元素从根一直带到最远的叶子上。由于我们重复了<code>n</code>次，因此排序步骤也是<code>nlogn</code>。</p><p><strong>最好最坏以及平均情况下的时间复杂度均为</strong><code>O(nlogn)</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown格式大全</title>
      <link href="/2024/02/26/MarkDown%E6%A0%BC%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
      <url>/2024/02/26/MarkDown%E6%A0%BC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown?"></a>什么是 Markdown?</h1><ol><li><strong>Markdown</strong> 是一款轻量级标记语言，不同于HTML <strong>(Hypertext Markup Language)<strong>，</strong>Markdown</strong> 的语法非常简单，且容易上手</li><li><strong>Markdown</strong> 以 <strong>纯文本格式</strong> 编写文档，依赖键盘而非鼠标，专注于<strong>写作本身</strong>，感受<strong>书写</strong>的魅力</li><li><strong>Markdown</strong> 的通过添加一些简单的 <strong>标识符</strong>，让文本具有<strong>恰到好处</strong>的格式</li><li><strong>Markdown</strong> 核心特征就是 <strong>删繁剪芜</strong>， <strong>简扼</strong> + <strong>精炼</strong></li><li><strong>Markdown</strong> 是 <strong>笔记</strong> 与 <strong>网页文章</strong> 的最佳载体</li><li><strong>Down</strong> 的核心：坐 <strong>下</strong> 来，就能把思维写 <strong>下</strong> 来 <ul><li><strong>牛津高阶英汉双解词典第九版</strong> 中，关于 <strong>down</strong> 的释义：</li></ul></li></ol><br><p><img src="https://z3.ax1x.com/2021/10/12/5mqsGF.png" class="lazyload placeholder" data-srcset="https://z3.ax1x.com/2021/10/12/5mqsGF.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="牛津9 down释义" title="牛津9 down释义"></p><br><h2 id="为什么要使用-Markdown"><a href="#为什么要使用-Markdown" class="headerlink" title="为什么要使用 Markdown?"></a>为什么要使用 Markdown?</h2><p>有朋友问我 ，<strong>Markdown</strong> 的效果 用Word 完全可以复现，甚至功能更多，那为何要用 <strong>Markdown</strong> 呢？</p><p><strong>答：</strong></p><ul><li>功能多，不一定是好事<ul><li>功能一多，选择就会变多，然后你会开始纠结……<ul><li>这个字号是不是该大一点呢？</li><li>这个颜色好像有点不太搭呢？</li><li>这个粗体，是不是该再加点颜色呢？</li><li>这个图片的位置看起来有点不大对劲呢？</li></ul></li><li>结果，写了半天，就憋出一点点东西<ul><li>写出来的内容…好像…也不咋滴</li></ul></li></ul></li></ul><p><strong>MD的优势：</strong></p><ol><li><strong>Markdown</strong> 让我们免于 <strong>被繁杂臃肿的功能晃花了眼</strong> 的困扰</li><li><strong>Markdown</strong> 让我们回归内容本身，拥抱笔记的<strong>内核</strong>，而非浮于<strong>表象</strong>的样式，写出<strong>高效精练</strong>的笔记！</li></ol><p>用 <strong>Markdown</strong> 写东西，记住一个原则</p><blockquote><p>能用10个字搞定的，绝不用11个字</p></blockquote><p>经常使用 <strong>Markdown</strong> 书写的朋友，也许会有一种奇妙的感触</p><ul><li>书写，会&#x3D;&#x3D;倒逼&#x3D;&#x3D;思维的跃进。像是有东西拽着你的思绪往前冲<ul><li>倒逼：逆向逼迫，反向推动</li></ul></li></ul><p><strong>关于标识符的滥用</strong></p><p>这个其实是写在最后的，之所以放在这里，是因为它<strong>很重要</strong>！</p><p>如果你有一定的MD语法基础，可以直接[[#19 避免标识符的滥用|点击跳转]]</p><br><h2 id="Markdown-相关软件推荐"><a href="#Markdown-相关软件推荐" class="headerlink" title="Markdown 相关软件推荐"></a>Markdown 相关软件推荐</h2><ul><li><strong>Markdown</strong> <strong>书写软件</strong> 推荐：<strong>Typora</strong>     优秀的 MD网页文章 书写软件<ul><li><a href="https://www.typora.io/" title="Typora编辑器">点击跳转下载地址</a><ul><li>#提示 以前是免费的，现在收费了，不过是买断制</li></ul></li></ul></li><li><strong>Markdown</strong> <strong>笔记软件</strong> 推荐：<strong>Obsidian</strong>    <strong>银河系最强</strong> <strong>MD+双向链</strong> 笔记软件 <ul><li><a href="https://obsidian.md/" title="银河系第一笔记软件 Obsidian">点击跳转下载地址</a></li></ul></li></ul><p><br><br></p><h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><ul><li><strong>提示1：</strong> 本教程推荐使用 <strong>Obsidian</strong> 打开阅读</li><li><strong>提示2：</strong> 下文提到的所有标识符都是 <strong>英文状态</strong> 的 <strong>！</strong></li></ul><h2 id="1-标题-目录"><a href="#1-标题-目录" class="headerlink" title="1. 标题&amp;目录"></a>1. 标题&amp;目录</h2><h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><ul><li>Markdown标题共有 <strong>六级</strong>，和 HTML 一样</li><li>区分  <strong>一级标题 → 六级标题</strong><ul><li><strong>标题 的格式：</strong>   <ul><li><strong><kbd>#</kbd></strong> × 标题级数  + <strong><kbd>空格</kbd></strong> + 文本内容</li></ul></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这是一段普通的文本</span><br><span class="line"></span><br><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br><span class="line"><span class="section">###### 这是六级标题 </span></span><br></pre></td></tr></table></figure><h3 id="1-2-目录"><a href="#1-2-目录" class="headerlink" title="1.2 目录"></a>1.2 目录</h3><ul><li><strong>目录的 格式：</strong><ul><li>在文档的顶部 输入 <strong><code>[toc]</code></strong> ，会根据 <strong>标题</strong> 自动生成目录  ( <strong>Table of Content</strong> )</li></ul></li><li>不是所有 <strong>MD编辑器</strong> 都支持目录生成<ul><li><strong>Obsidian</strong> 就不支持，不过 <strong>OB</strong> 是自带大纲的，就是目录的效果</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入下方内容会生成一个目录：</span><br><span class="line"></span><br><span class="line">[toc]</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="2-斜体-粗体"><a href="#2-斜体-粗体" class="headerlink" title="2. 斜体&amp;粗体"></a>2. 斜体&amp;粗体</h2><br><h3 id="2-1-斜体"><a href="#2-1-斜体" class="headerlink" title="2.1 斜体"></a>2.1 斜体</h3><ul><li><strong>斜体 的格式：</strong><ol><li><code>*</code> + 文本内容 + <code>*</code></li><li><code>_</code> + 文本内容 + <code>_</code>   ( 下划线 )</li></ol></li><li><strong>说明：</strong><ul><li>斜体文本，首尾只有 <strong>单个</strong> 标识符</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一段普通文本</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*这里是一段斜体文本*</span></span><br><span class="line"><span class="emphasis">_这也是一段斜体文本_</span></span><br></pre></td></tr></table></figure><h4 id="示范"><a href="#示范" class="headerlink" title="示范"></a>示范</h4><p>这是一段普通文本</p><p><em>这里是一段斜体文本</em><br><em>这也是一段斜体文本</em></p> <br><h3 id="2-2-粗体"><a href="#2-2-粗体" class="headerlink" title="2.2 粗体"></a>2.2 粗体</h3><ul><li><p><strong>粗体 的格式：</strong></p><ol><li><code>**</code> + 文本内容 + <code>**</code></li><li><code>__</code> + 文本内容 + <code>__</code>    (这里是两个 <strong><kbd>_</kbd></strong> )</li></ol></li><li><p><strong>说明：</strong> </p><ul><li>粗体文本，首尾各有 <strong>两个</strong> 标识符</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一段普通文本</span><br><span class="line"></span><br><span class="line"><span class="strong">**这里是一段加粗文本**</span></span><br><span class="line"><span class="strong">__这也是一段加粗文本__</span></span><br></pre></td></tr></table></figure><h4 id="示范-1"><a href="#示范-1" class="headerlink" title="示范"></a>示范</h4><p>这是一段普通文本</p><p><strong>这里是一段加粗文本</strong><br><strong>这也是一段加粗文本</strong></p><br><h3 id="2-3-粗斜体-斜粗体"><a href="#2-3-粗斜体-斜粗体" class="headerlink" title="2.3 粗斜体 (斜粗体)"></a>2.3 粗斜体 (斜粗体)</h3><ul><li><p><strong>粗斜体 的格式：</strong></p><ol><li><code>***</code> + 文本内容 + <code>***</code></li><li><code>___</code> + 文本内容 + <code>___</code>   （ 这里是3个 <kbd>_</kbd> )</li><li><code>**_</code> + 文本内容 + <code>_**</code></li><li><code>__*</code> + 文本内容 +  <code>*__</code></li><li><code>*__</code> + 文本内容 + <code>__*</code></li><li><code>_**</code> + 文本内容 + <code>**_</code></li></ol></li><li><p><strong>说明：</strong></p><ul><li>粗斜体文本，首尾各有 <strong>三个</strong> 标识符</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这是一段普通文本</span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本1*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本2_</span>__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">_粗斜体文本3_</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">*粗斜体文本4*</span>__</span></span><br><span class="line"><span class="emphasis">*<span class="strong">__粗斜体文本5__</span>*</span></span><br><span class="line"><span class="emphasis">_<span class="strong">**粗斜体文本6**</span>_</span></span><br></pre></td></tr></table></figure><h4 id="示范-2"><a href="#示范-2" class="headerlink" title="示范"></a>示范</h4><p>这是一段普通文本</p><p><em><strong>粗斜体文本1</strong></em><br><em><strong>粗斜体文本2</strong></em><br><strong><em>粗斜体文本3</em></strong><br><strong><em>粗斜体文本4</em></strong><br><em><strong>粗斜体文本5</strong></em><br><em><strong>粗斜体文本6</strong></em></p><br><h3 id="2-4-斜体包含粗体"><a href="#2-4-斜体包含粗体" class="headerlink" title="2.4 斜体包含粗体"></a>2.4 斜体包含粗体</h3><ul><li><p><strong>斜体中包含粗体 的格式：</strong></p><ol><li><code>*</code> +  斜体文本 + <code>**</code> + 粗体文本 + <code>**</code> + 斜体文本 + <code>*</code></li><li><code>_</code> + 斜体文本 + <strong><code>__</code></strong> + 粗体文本 + <code>__</code> + 斜体文本 + <code>_</code> （ 这里是两个 <strong><kbd>_</kbd></strong> )</li><li><code>*</code> + 斜体文本 + <code>__</code> + 粗体文本 + <code>__</code> + 斜体文本 + <code>*</code></li><li><code>_</code> + 斜体文本 + <code>**</code> + 粗体文本 + <code>**</code> + 斜体文本 + <code>_</code></li></ol></li><li><p><strong>说明：</strong>  </p><ul><li><strong>斜体</strong> 中包含 <strong>粗体</strong>，其实就是嵌套的关系，<strong>外层</strong> 是 <strong>斜体</strong>，<strong>内层</strong> 是 <strong>粗体</strong></li><li>外层是<strong>斜体</strong>，标识符是<strong>单个</strong>；内层是<strong>粗体</strong>，标识符是<strong>两个</strong></li><li>因为 <strong>粗体</strong> 是被包裹在 <strong>斜体</strong> 中的，所以显示效果为 <strong>斜粗体</strong></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这是一段普通文本</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*这里是一段斜体中<span class="strong">**包含粗体**</span>的文字*</span></span><br><span class="line"><span class="emphasis">_这也是一段斜体中<span class="strong">**包含粗体**</span>的文字_</span></span><br><span class="line"><span class="emphasis">*这又是一段斜体中<span class="strong">__包含粗体__</span>的文字*</span></span><br><span class="line"><span class="emphasis">_这还是一段斜体中<span class="strong">**包含粗体**</span>的文字_</span></span><br></pre></td></tr></table></figure><h4 id="示范-3"><a href="#示范-3" class="headerlink" title="示范"></a>示范</h4><p>这是一段普通文本</p><p><em>这里是一段斜体中<strong>包含粗体</strong>的文字</em><br><em>这也是一段斜体中<strong>包含粗体</strong>的文字</em><br><em>这又是一段斜体中__包含粗体__的文字</em><br><em>这还是一段斜体中<strong>包含粗体</strong>的文字</em></p><br><h3 id="2-5-粗体包含斜体"><a href="#2-5-粗体包含斜体" class="headerlink" title="2.5 粗体包含斜体"></a>2.5 粗体包含斜体</h3><ul><li><strong>粗体中包含斜体 的格式：</strong><ol><li><code>**</code> + 粗体文本 + <code>*</code> + 斜体文本 + <code>*</code> + 粗体文本 + <code>**</code></li><li><code>__</code> + 粗体文本 + <code>_</code> + 斜体文本 + <code>_</code> + 粗体文本 + <code>__</code>   （ 这里是两个 <strong><kbd>_</kbd></strong> )</li><li><code>**</code> + 粗体文本 + <code>_</code> + 斜体文本 + <code>_</code> + 粗体文本 + <code>**</code></li><li><code>__</code> + 粗体文本 + <code>*</code> + 斜体文本 +  <code>*</code> + 粗体文本 + <code>__</code></li></ol></li><li><strong>说明：</strong><ul><li><strong>粗体</strong> 中包含 <strong>斜体</strong>，也就是嵌套的关系，<strong>外层</strong> 是 <strong>粗体</strong>，<strong>内层</strong> 是 <strong>斜体</strong></li><li>外层是<strong>粗体</strong>，标识符是<strong>两个</strong>；内层是<strong>斜体</strong>，标识符是<strong>单个</strong></li><li>因为 <strong>斜体</strong> 是被包裹在 <strong>粗体</strong> 中的，所以显示效果为 <strong>粗斜体</strong></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这是一段普通文本</span><br><span class="line"></span><br><span class="line"><span class="strong">**这里是一段粗体中<span class="emphasis">*包含斜体*</span>的文字**</span></span><br><span class="line"><span class="strong">__这也是一段粗体中<span class="emphasis">_包含斜体_</span>的文字__</span></span><br><span class="line"><span class="strong">**这又是一段粗体中<span class="emphasis">_包含斜体_</span>的文字**</span></span><br><span class="line"><span class="strong">__这还是一段粗体中<span class="emphasis">*包含斜体*</span>的文字__</span></span><br></pre></td></tr></table></figure><h4 id="示范-4"><a href="#示范-4" class="headerlink" title="示范"></a>示范</h4><p>这是一段普通文本</p><p><strong>这里是一段粗体中<em>包含斜体</em>的文字</strong><br><strong>这也是一段粗体中_包含斜体_的文字</strong><br><strong>这又是一段粗体中_包含斜体_的文字</strong><br><strong>这还是一段粗体中<em>包含斜体</em>的文字</strong></p><p><br><br></p><h2 id="3-线"><a href="#3-线" class="headerlink" title="3. 线"></a>3. 线</h2><br><h3 id="3-1-水平分割线"><a href="#3-1-水平分割线" class="headerlink" title="3.1 水平分割线"></a>3.1 水平分割线</h3><ul><li>水平分割线由至少 <strong>3</strong> 个 <code>*</code> 或 <code>-</code> 组成</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">下面是一条水平分割线：</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h4 id="示范-5"><a href="#示范-5" class="headerlink" title="示范"></a>示范</h4><hr><hr><br><h3 id="3-2-文本删除线"><a href="#3-2-文本删除线" class="headerlink" title="3.2 文本删除线"></a>3.2 文本删除线</h3><ul><li><strong>删除线 的格式：</strong><ul><li><strong><code>~~</code></strong> + 文本内容 +<strong><code>~~</code></strong>   首尾各加两个 <strong><kbd>~</kbd></strong> 波浪号</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~这是一段加了删除线的文本~~</span><br></pre></td></tr></table></figure><h4 id="示范-6"><a href="#示范-6" class="headerlink" title="示范"></a>示范</h4><p><del>这是一段加了删除线的文本</del></p>  <br><h3 id="3-3-文本下划线"><a href="#3-3-文本下划线" class="headerlink" title="3.3 文本下划线"></a>3.3 文本下划线</h3><ul><li>下划线的格式，和 HTML 是一样的 <ul><li><strong><code>&lt;u&gt;</code></strong> + 文本内容 + <strong><code>&lt;/u&gt;</code></strong></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>这是一段加了下划线的文本<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="示范-7"><a href="#示范-7" class="headerlink" title="示范"></a>示范</h4><p><u>这是一段加了下划线的文本</u></p><p><br><br></p><h2 id="4-列表-引用"><a href="#4-列表-引用" class="headerlink" title="4. 列表&amp;引用"></a>4. 列表&amp;引用</h2><br><h3 id="4-1-有序列表"><a href="#4-1-有序列表" class="headerlink" title="4.1 有序列表"></a>4.1 有序列表</h3><ul><li><p><strong>有序列表 的格式：</strong></p><ul><li><strong><code>1.</code></strong> + <strong><kbd>空格</kbd></strong> + 文本内容</li></ul></li><li><p><strong>说明：</strong></p><ul><li>输入文本内容后，敲击 <strong><kbd>Enter</kbd></strong> 自动补全格式，并进入 <strong>下个</strong> 有序列表</li><li>若需要在同个列表内，增加 <strong>换行显示</strong> 的内容 (<strong>但不进入下个列表</strong>)<br>敲击 <strong><kbd>Shift</kbd></strong> + <strong><kbd>Enter</kbd></strong> ，即可另起一行输入文本</li><li>在有序列表的中间，插入一个新的列表，后面列表的 <strong>数字序号</strong> 会自动 <strong>递进</strong> 一层</li><li>即便在源代码模式中修改了数字序号，渲染界面依然是 <strong>依照顺序</strong> 显示的</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 这是第一个有序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">2.</span> 这是第二个有序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">3.</span> 这是第三个有序列表 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 这是第一个有序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">   这是同个列表下，另起一行的文本内容 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">2.</span> 这是第二个有序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">   这是同个列表下，另起一行的文本内容 </span><br></pre></td></tr></table></figure><h4 id="示范-8"><a href="#示范-8" class="headerlink" title="示范"></a>示范</h4><ol><li><p>这是第一个有序列表 </p></li><li><p>这是第二个有序列表 </p></li><li><p>这是第三个有序列表 </p></li><li><p>这是第一个有序列表<br>这是同个列表下，另起一行的文本内容</p></li><li><p>这是第二个有序列表<br>这是同个列表下，另起一行的文本内容</p></li></ol><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>由于有序列表存在<strong>强制排序性</strong>，它的数字序号必然是<strong>逐一递进</strong>的<br>若你希望内容前的数字，不依照<strong>递进顺序</strong>排序，或者以 <strong>整百</strong>，<strong>整十数</strong> 排序</li><li>可以配合<strong>无序列表</strong>，在无序列表中输入：<ul><li><code>数字</code> + <code>.</code> + 内容<br>#注意  点号 与 内容 之间，<strong>没有空格</strong>   (其实有空格也行，就是会感觉有点奇怪)</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 10.这是无序列表下，整十数排列的内容</span><br><span class="line"><span class="bullet">-</span> 20.这是无序列表下，整十数排列的内容</span><br><span class="line"><span class="bullet">-</span> 30.这是无序列表下，整十数排列的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 100.这是无序列表下，整百数排列的内容</span><br><span class="line"><span class="bullet">-</span> 200.这是无序列表下，整百数排列的内容</span><br><span class="line"><span class="bullet">-</span> 300.这是无序列表下，整百数排列的内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>10.这是无序列表下，整十数排列的内容</li><li>20.这是无序列表下，整十数排列的内容</li><li>30.这是无序列表下，整十数排列的内容</li></ul><br><ul><li>100.这是无序列表下，整百数排列的内容</li><li>200.这是无序列表下，整百数排列的内容</li><li>300.这是无序列表下，整百数排列的内容</li></ul><br><h3 id="4-2-无序列表"><a href="#4-2-无序列表" class="headerlink" title="4.2 无序列表"></a>4.2 无序列表</h3><ul><li><strong>无序列表 的格式：</strong></li><li><strong><kbd>-</kbd></strong> + <strong><kbd>空格</kbd></strong> + 文本内容</li><li><strong>说明：</strong><ul><li>输入文本内容后，敲击 <strong><kbd>Enter</kbd></strong> 自动补全格式，并进入 <strong>下个</strong> 无序列表</li><li>若需要在同个列表内，增加<strong>换行</strong>显示的内容 (<strong>但不进入下个列表</strong>)<br>敲击 <strong><kbd>Shift</kbd></strong> + <strong><kbd>Enter</kbd></strong> ，即可另起一行输入文本</li></ul></li><li><strong>补充：</strong><ul><li>在<strong>Obsidian</strong>中，按下 <strong><kbd>Ctrl</kbd></strong> + <strong><kbd>Enter</kbd></strong></li><li>即可快速生成一个无序列表</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 这是第1个无序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">-</span> 这是第2个无序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">-</span> 这是第3个无序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 这是第一个无序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">  这是同个列表下，另起一行的文本内容</span><br><span class="line"><span class="bullet">-</span> 这是第二个无序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">  这是同个列表下，另起一行的文本内容 </span><br></pre></td></tr></table></figure><h4 id="示范-9"><a href="#示范-9" class="headerlink" title="示范"></a>示范</h4><ul><li>这是第1个无序列表</li><li>这是第2个无序列表</li><li>这是第3个无序列表</li></ul><br><ul><li>这是第一个无序列表<br>这是同个列表下，另起一行的文本内容</li><li>这是第二个无序列表<br>这是同个列表下，另起一行的文本内容</li></ul><br><h3 id="4-3-引用"><a href="#4-3-引用" class="headerlink" title="4.3 引用"></a>4.3 引用</h3><ul><li><strong>引用 的格式：</strong><ul><li><strong><kbd>></kbd></strong> + 文本内容 （<strong>不需要空格</strong>)</li></ul></li><li><strong>说明：</strong><ul><li><strong>同个引用段落</strong>内的换行直接敲击 <strong><kbd>Enter</kbd></strong> 即可</li><li>若需添加 <strong>第二个独立引用段落</strong> ，连续敲击 <strong>两下</strong> <strong><kbd>Enter</kbd></strong> 即可</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是第一段引用文本的第1行 &lt;!-- (Enter) --&gt;</span><br><span class="line">&gt;这是第一段引用文本的第2行 &lt;!-- (Enter) --&gt;</span><br><span class="line">&lt;!-- (Enter) --&gt;</span><br><span class="line">&gt;这是第二段引用文本的第1行 &lt;!-- (Enter) --&gt;</span><br><span class="line">&gt;这是第二段引用文本内第2行</span><br></pre></td></tr></table></figure><h4 id="示范-10"><a href="#示范-10" class="headerlink" title="示范"></a>示范</h4><blockquote><p>这是第一段引用文本的第1行<br>这是第一段引用文本的第2行</p></blockquote><blockquote><p>这是第二段引用文本的第1行<br>这是第二段引用文本的第2行</p></blockquote><br><h3 id="4-4-缩进-退格"><a href="#4-4-缩进-退格" class="headerlink" title="4.4 缩进&amp;退格"></a>4.4 缩进&amp;退格</h3><p><strong>在列表和引用的书写过程中，我们需要利用 &#x3D;&#x3D;缩进&#x3D;&#x3D; 与 &#x3D;&#x3D;退格&#x3D;&#x3D; ，让文章肌理分明，更具层级</strong></p><ul><li><p><strong>缩进：</strong></p><ol><li><strong><kbd>Tab</kbd></strong></li><li><strong><kbd>Ctrl</kbd></strong> + <strong><kbd>[</kbd></strong> &nbsp; (左中括号)</li></ol></li><li><p><strong>退格：</strong></p><ol><li><strong><kbd>Shift</kbd></strong> + <strong><kbd>Tab</kbd></strong></li><li><strong><kbd>Ctrl</kbd></strong> + <strong><kbd>]</kbd></strong>&nbsp;（右中括号）</li></ol></li></ul><br><h4 id="4-4-1-有序列表的缩-退"><a href="#4-4-1-有序列表的缩-退" class="headerlink" title="4.4.1 有序列表的缩&amp;退"></a>4.4.1 有序列表的缩&amp;退</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一级有序列表1 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">1.</span> 第二级有序列表1    &lt;!-- 写文本之前，先( Tab 或 Ctrl + ] ) ；写完文本后，再(Enter) --&gt;</span><br><span class="line"><span class="bullet">2.</span> 第二级有序列表2 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">2.</span> 第一级有序列表2    &lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --&gt; </span><br></pre></td></tr></table></figure><ul><li><strong>补充说明：</strong><ul><li>有序列表的<strong>数字序号</strong>，即便你在源代码模式里 强行改掉 数字，它仍然会 <strong>依照顺序</strong> 显示</li></ul></li></ul><h5 id="示范-11"><a href="#示范-11" class="headerlink" title="示范"></a>示范</h5><ol><li>第一级有序列表1<ol><li>第二级有序列表1</li><li>第二级有序列表2</li></ol></li><li>第一级有序列表2</li></ol><br><h4 id="4-4-2-无序列表的缩-退"><a href="#4-4-2-无序列表的缩-退" class="headerlink" title="4.4.2 无序列表的缩&amp;退"></a>4.4.2 无序列表的缩&amp;退</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 第一级无序列表1 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">-</span> 第二级无序列表1  &lt;!-- 写文本前，先( Tab 或 Ctrl + ] ) ；写完后，再(Enter) --&gt;</span><br><span class="line"><span class="bullet">-</span> 第二级无序列表2 &lt;!-- (Enter) --&gt;</span><br><span class="line"><span class="bullet">-</span> 第一级无序列表2  &lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --&gt;</span><br></pre></td></tr></table></figure><h5 id="示范-12"><a href="#示范-12" class="headerlink" title="示范"></a>示范</h5><ul><li>第一级无序列表1<ul><li>第二级无序列表1</li><li>第二级无序列表2</li></ul></li><li>第一级无序列表2</li></ul><br><h4 id="4-4-3-引用的缩-退"><a href="#4-4-3-引用的缩-退" class="headerlink" title="4.4.3 引用的缩&amp;退"></a>4.4.3 引用的缩&amp;退</h4><ul><li>引用的 <strong>缩进</strong> 和列表 <strong>不同</strong><ul><li>引用需另起一行，并额外多打一个 <kbd>></kbd> 来完成 <strong>缩进</strong></li></ul></li><li>引用的 <strong>退格</strong> 与列表 <strong>相同</strong><ol><li><strong><kbd>Shift</kbd></strong> + <strong><kbd>Tab</kbd></strong></li><li><strong><kbd>Ctrl</kbd></strong> + <strong><kbd>]</kbd></strong>   （右中括号）</li></ol></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;第一级引用1 &lt;!-- (enter) --&gt;</span><br><span class="line">&gt;&gt;第二级引用1 &lt;!-- 先打1个 &gt; (这里的第一个 &gt; 是会自动补充的，只需额外增补1个即可) ，再(enter) --&gt;</span><br><span class="line">&gt;&gt;第二级引用2 &lt;!-- (enter) --&gt;</span><br><span class="line">&gt;第一级引用2   &lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --&gt;</span><br></pre></td></tr></table></figure><h5 id="示范-13"><a href="#示范-13" class="headerlink" title="示范"></a>示范</h5><blockquote><p>第一级引用1</p><blockquote><p>第二级引用1<br>第二级引用2</p></blockquote><p>第一级引用2</p></blockquote><br><ul><li><strong>补充：</strong><br>在 <strong>Obsidian</strong> 中，引用的退格是不太一样的</li><li>**Obsidian **中，如果想让已经缩进的引用 <strong>退回一层</strong><ul><li>得使用 <strong><code>Shift</code></strong> + <strong><code>Enter</code></strong> ，配合方向键，在多个  <strong><code>&gt;</code></strong>  之间灵活断行<br>并在下一行 根据需要 选择性补充 <strong><code>&gt;</code></strong></li></ul></li><li>这个用文字比较难以描述，这里选择用2个带键位的 <strong>Gif图</strong> 来描述</li></ul><p><strong>Gif演示1：</strong></p><br><p><img src="https://z3.ax1x.com/2021/08/09/fGPDVs.gif" class="lazyload placeholder" data-srcset="https://z3.ax1x.com/2021/08/09/fGPDVs.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="引用退格1"></p><br><ul><li><strong>效果1：</strong></li></ul><blockquote><p>111</p><blockquote><p>222</p><blockquote><p>333</p></blockquote></blockquote><blockquote><p>444</p></blockquote><p>555</p></blockquote><br><p><strong>Gif演示2：</strong><br><br></p><p><img src="https://z3.ax1x.com/2021/08/09/fGA1Qf.gif" class="lazyload placeholder" data-srcset="https://z3.ax1x.com/2021/08/09/fGA1Qf.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="引用退格2"></p><br><ul><li><strong>效果2：</strong></li></ul><blockquote><p>111</p><blockquote><p>222</p><blockquote><p>333</p></blockquote></blockquote><blockquote><p>444</p><blockquote><p>555</p></blockquote></blockquote><p>666</p><p>777</p></blockquote><br><h4 id="4-4-4-有序-无序-引用-连续套娃"><a href="#4-4-4-有序-无序-引用-连续套娃" class="headerlink" title="4.4.4 有序&amp;无序&amp;引用 连续套娃"></a>4.4.4 有序&amp;无序&amp;引用 连续套娃</h4><ul><li><strong>有序列表</strong>、<strong>无序列表</strong>、<strong>引用</strong> 三者之间，可以相互嵌套</li><li><strong>核心键</strong> ： <strong><kbd>Shift</kbd></strong> + <strong><kbd>Enter</kbd></strong>   <strong>&amp;</strong>   <strong><kbd>Enter</kbd></strong>   <strong>&amp;</strong>   <strong><kbd>Shift</kbd></strong> + <strong><kbd>Tab</kbd></strong>  ( 或 <strong><kbd>Ctrl</kbd></strong> + <strong><kbd>[</kbd></strong> )<ul><li><strong><kbd>Shift</kbd></strong> + <strong><kbd>Enter</kbd></strong>  在切换格式的嵌套中，是 自带一层 <strong>缩进</strong> 效果的</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一级 有序列表1 &lt;!-- (Shift + Enter) --&gt; </span><br><span class="line"><span class="bullet">-</span> 第二级 无序列表1 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line"><span class="code">&gt;第三级 引用1  &lt;!-- (Enter) --&gt;</span></span><br><span class="line"><span class="code">- 第四级 无序列表2 &lt;!-- (Shift + Enter) --&gt;</span></span><br><span class="line"><span class="code">            1. 第五级 有序列表2 &lt;!-- (Enter) --&gt;</span></span><br><span class="line"><span class="code">            - 第四级 无序列表3   &lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) ；写完后再 (Enter) --&gt;</span></span><br><span class="line"><span class="code">        &gt;第三级 引用2  &lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) ；写完后再 (Enter × 2) --&gt;</span></span><br><span class="line"><span class="code">    - 第二级 无序列表4  &lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) --&gt;</span></span><br><span class="line"><span class="code">2. 第一级 有序列表3  &lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="示范-14"><a href="#示范-14" class="headerlink" title="示范"></a>示范</h5><ol><li><p>第一级 有序列表1</p><ul><li><p>第二级 无序列表1</p><blockquote><p>第三级 引用1</p><ul><li>第四级 无序列表2<ol><li>第五级 有序列表2</li></ol></li><li>第四级 无序列表3</li></ul><p>第三级 引用2</p></blockquote></li><li><p>第二级 无序列表4</p></li></ul></li><li><p>第一级 有序列表3</p></li></ol><h4 id="4-4-5-Obsidian-的一些缩退问题"><a href="#4-4-5-Obsidian-的一些缩退问题" class="headerlink" title="4.4.5 Obsidian 的一些缩退问题"></a>4.4.5 Obsidian 的一些缩退问题</h4><ul><li><strong>Obsidian</strong> 在列表首行使用缩进的时候，后续的列表会出现一些问题<ul><li><code>Tab</code> 和 <code>Shift + tab</code>  会无法 缩进 退格<ul><li>可以使用 <code>Ctrl + ]</code> 与 <code>Ctrl + [</code>  来解决问题</li></ul></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> - 这是第一段就被缩进的列表</span><br><span class="line"><span class="bullet">-</span> 这是第二段被再次缩进的列表  &lt;!-- 这里需按两次 Ctrl + ] ,Tab键是无效的 --&gt;</span><br><span class="line"><span class="bullet">  -</span> 这是第三段列表  &lt;!-- Ctrl + [ --&gt;</span><br></pre></td></tr></table></figure><ul><li><ul><li>这是第一段就被缩进的列表<ul><li>这是第二段被再次缩进的列表</li></ul></li><li>这是第三段列表</li></ul></li></ul><p><br><br></p><h2 id="5-网页链接与图像"><a href="#5-网页链接与图像" class="headerlink" title="5. 网页链接与图像"></a>5. 网页链接与图像</h2><br><h3 id="5-1-网页链接"><a href="#5-1-网页链接" class="headerlink" title="5.1 网页链接"></a>5.1 网页链接</h3><ul><li><strong>网页链接的 格式：</strong><ul><li><strong><kbd>[</kbd></strong> + 显示文本内容 + <strong><kbd>]</kbd></strong> + <strong><kbd>(</kbd></strong> + 链接地址 + <strong><kbd>空格</kbd></strong>  + <strong><kbd>"</kbd></strong> + 提示信息文本 + <strong><kbd>"</kbd></strong> + <strong><kbd>)</kbd></strong></li></ul></li><li><strong>说明：</strong><ul><li>显示文本内容，是在渲染界面实际 <strong>可见</strong> 的文本，用以 <strong>说明</strong> 链接</li><li>提示信息文本，需鼠标悬停于 <strong>显示文本内容</strong> 方可触发，用于增加额外提示信息<ul><li>#注意 <strong><code>&quot;提示信息文本&quot;</code></strong>  是<strong>可选项</strong>，一般不会填</li><li>一般来讲，需按住 <strong><kbd>Ctrl</kbd></strong> + <strong><code>鼠标左键点击</code></strong>  才可跳转链接，不过也有 <strong>直接鼠标点击</strong> 就能跳转的</li></ul></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">显示文本内容</span>](<span class="link">链接地址 &quot;提示信息文本&quot;</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">百度一下，你就知道</span>](<span class="link">http://www.baidu.com &quot;按住Ctrl点击跳转百度&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>示范：</strong></p><p><a href="http://www.baidu.com/" title="按住Ctrl点击跳转百度">百度一下，你就知道</a></p><br><h4 id="5-1-1链接的加粗"><a href="#5-1-1链接的加粗" class="headerlink" title="5.1.1链接的加粗"></a>5.1.1链接的加粗</h4><ul><li><p><strong>格式有两种：</strong></p><ol><li><p>把一对 <kbd>**</kbd> 加在 &#x3D;&#x3D;显示文本内容&#x3D;&#x3D;的首尾</p><ul><li><strong>格式1：</strong><code>[**显示文本内容**](链接地址)</code></li><li><strong>效果：</strong> <a href="http://www.baidu.com/"><strong>百度一下，你就知道</strong></a></li></ul></li><li><p>把一对 <kbd>**</kbd> 加在 链接格式&#x3D;&#x3D;整体&#x3D;&#x3D; 的首尾</p><ul><li><strong>格式2：</strong><code>**[显示文本内容](链接地址)**</code></li><li><strong>效果：</strong> <strong><a href="http://www.baidu.com/">百度一下，你就知道</a></strong></li></ul></li></ol></li></ul><p><br><br></p><h3 id="5-2-图像"><a href="#5-2-图像" class="headerlink" title="5.2 图像"></a>5.2 图像</h3><ul><li><strong>图像格式：</strong><ul><li>图像格式，就是在网页链接前面加个  <strong><kbd>!</kbd></strong>  (英文格式的)，**<code>!</code>** 代表 <strong>可见</strong></li><li>图片的提示信息，和网页链接一样，写在 <strong><code>&quot; &quot;</code></strong>  内</li><li><strong><code>[ ]</code></strong>  方括号里的文字信息在 <strong>Markdown</strong> 没啥实质的作用，只是方便在源代码模式下，知道这个图片是什么，在渲染界面是不会显示的。有点类似于HTML  <strong>img标签</strong> 里的 <strong>alt属性</strong>。</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">文字信息</span>](<span class="link">图片链接 &quot;提示文本信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">湘湖1</span>](<span class="link">https://z3.ax1x.com/2021/08/06/fuNkXq.jpg &quot;湘湖一角&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong>补充：</strong></p><ul><li>图像链接可以是<strong>本地</strong>的，也可以是<strong>在线</strong>的<ul><li>本地图像直接  <strong><code>Ctrl + C</code></strong>  黏贴，**<code>Ctrl + V</code>**  复制 就可以</li><li>在线图像推荐使用 <a href="https://imgtu.com/" title="这是一个在线图床网址">图床</a></li></ul></li><li>调整图像的大小需要使用 HTML 和 CSS，在 <strong>Typora编辑器</strong> 中右键可以直接缩放图片<br>本质是转成了HTML的格式，最后会有一个 <code>style=&quot;zoom: %;&quot;</code> ，这里数值可以自己修改</li><li>如果有使用 <strong>Obsidian</strong> 的朋友，在线图片链接是通用的。不过，因为 <strong>Obsidian</strong> 是双向链笔记<br>它的<strong>本地图片</strong>格式不太一样<ul><li><strong><code>![[图片名]]</code></strong><ul><li><strong>Obsidian</strong> 中的图片是以<strong>双链</strong>的格式引用在目标笔记中，用 <strong><kbd>!</kbd></strong> 使它可见</li><li><strong>Obsidian</strong>的图片设置大小是用 <strong><kbd>|</kbd></strong> 分隔，后面写宽度数值，单位是px。<br>设定好宽度，高度会自动<strong>等比例调整</strong><ul><li><code>![[图片名|宽度数值]]</code><ul><li>若想自主调整图片宽高，则用：<ul><li><code>![[图片名|宽度数值x高度数值]]</code><ul><li>#提示 这里的 <code>x</code> 是 英文字母<strong>x</strong></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>如果是<strong>在线图床</strong>，需要调整图片大小：<ul><li><code>![图床|宽度数值](链接地址)</code></li></ul></li></ul></li></ul><h4 id="示范-15"><a href="#示范-15" class="headerlink" title="示范"></a>示范</h4><p><img src="https://z3.ax1x.com/2021/08/06/fuNkXq.jpg" class="lazyload placeholder" data-srcset="https://z3.ax1x.com/2021/08/06/fuNkXq.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="湘湖1|400" title="湘湖一角"></p><p><br><br></p><h2 id="6-表格"><a href="#6-表格" class="headerlink" title="6. 表格"></a>6. 表格</h2><ul><li>Markdown的表格，比HTML简单很多<ul><li><strong><kbd>|</kbd></strong>  是构成表格的主要 <strong>框架</strong></li><li><strong><kbd>-</kbd></strong> 区分 <strong>表头</strong> 和 <strong>表格主体</strong></li><li><strong><kbd>:</kbd></strong> 控制 表格内 <strong>文本内容</strong> 的 <strong>对齐方式</strong></li><li>**Typora编辑器中 **  输入 <strong><code>Ctrl + T</code></strong> 即可快速插入表格，自由定义样式</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|这里是表头1|这里是表头2|这里是表头3|</span><br><span class="line">|:-|:-:|-:|    &lt;!--区分表头和表格主体，:代表文本对齐方式，分别是左对齐，居中对齐，右对齐--&gt;</span><br><span class="line">|单元格数据1|单元格数据2|单元格数据3|</span><br><span class="line">|单元格数据4|单元格数据5|单元格数据6|</span><br></pre></td></tr></table></figure><h4 id="示范-16"><a href="#示范-16" class="headerlink" title="示范"></a>示范</h4><table><thead><tr><th align="left">这里是表头1</th><th align="center">这里是表头2</th><th align="right">这里是表头3</th></tr></thead><tbody><tr><td align="left">单元格数据1</td><td align="center">单元格数据2</td><td align="right">单元格数据3</td></tr><tr><td align="left">单元格数据4</td><td align="center">单元格数据5</td><td align="right">单元格数据6</td></tr></tbody></table><br><h3 id="6-1-表格中文本内容的换行"><a href="#6-1-表格中文本内容的换行" class="headerlink" title="6.1 表格中文本内容的换行"></a>6.1 表格中文本内容的换行</h3><ul><li>Mardown中表格，它的宽高是由 单元格数据内的文本内容 <strong>撑开</strong> 的</li><li>当我们输入一段很长很长的文本，它所在的单元格会变得过宽</li></ul><p><strong>如下图所示：</strong></p><table><thead><tr><th align="center">表头1</th><th align="center">表头2</th></tr></thead><tbody><tr><td align="center">这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文本</td><td align="center">普通文本</td></tr></tbody></table><ul><li>若想对一段长文本进行换行，可以在 <strong>中间</strong> 插入一个  <strong><code>&lt;br&gt;</code></strong>  （ 换行标签 )</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 表头1 |  表头2 |</span><br><span class="line">|:-:|:-:|</span><br><span class="line">|这是第一行文本<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>这是另起一行的文本|普通文本|</span><br></pre></td></tr></table></figure><h4 id="示范-17"><a href="#示范-17" class="headerlink" title="示范"></a>示范</h4><table><thead><tr><th align="center">表头1</th><th align="center">表头2</th></tr></thead><tbody><tr><td align="center">这是第一行文本<br>这是另起一行的文本</td><td align="center">普通文本</td></tr></tbody></table><p><br><br></p><h2 id="7-代码域"><a href="#7-代码域" class="headerlink" title="7. 代码域"></a>7. 代码域</h2><br><h3 id="7-1-行内代码"><a href="#7-1-行内代码" class="headerlink" title="7.1 行内代码"></a>7.1 行内代码</h3><ul><li><strong>行内代码 的格式：</strong><ul><li>输入两个 <strong><kbd>`</kbd></strong> 反引号 ，在中间写代码内容</li></ul></li><li><strong>补充：</strong><ul><li>行内代码不一定非得写代码，也可以作为**<code>着重标记</code>**，突出显示内容</li><li>行内代码中，源代码界面和渲染界面是完全一致的，标识符会失效</li><li><strong>所谓行内代码：</strong> 只要你的屏幕足够宽，它就不会换行</li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`这是一段行内代码`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`print(&quot;Hello, World!&quot;)`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`这是一行突出显示的文本内容`</span></span><br></pre></td></tr></table></figure><h4 id="示范-18"><a href="#示范-18" class="headerlink" title="示范"></a>示范</h4><p><code>&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;</code></p><br><p><code>print(&quot;Hello, World!&quot;)</code></p><br><p><code>这是一行突出显示的文本内容</code></p><br><h3 id="7-2-代码块"><a href="#7-2-代码块" class="headerlink" title="7.2 代码块"></a>7.2 代码块</h3><ul><li><strong>代码块 的格式：</strong><ol><li>在首行和末行各加 <strong>三个</strong> <strong><kbd>`</kbd></strong>  反引号<ul><li><strong><code>```</code>** + 语言种类<br>代码内容<br>**<code>```</code></strong></li></ul></li><li>在首行和末行各加 <strong>三个</strong> <strong><kbd>~</kbd></strong>  波浪号<ul><li><strong><code>~~~</code></strong> + 语言种类<br>代码内容<br><strong><code>~~~</code></strong></li></ul></li></ol></li><li><strong>补充：</strong><ul><li>在代码块也不一定要写代码，可以写<strong>一段</strong>突出的文本内容，语言类型可以填写 <strong>txt</strong> 或者 <strong>干脆不写</strong></li><li>代码块中，源代码界面和渲染界面是完全一致的，标识符会失效</li><li>在 <strong>Typora编辑器</strong> ，用键盘按键脱离代码块区域，需输入：  <strong><kbd>Ctrl</kbd> + <kbd>Enter</kbd></strong></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```语言种类</span></span><br><span class="line"><span class="code">代码内容</span></span><br><span class="line"><span class="code">代码内容</span></span><br><span class="line"><span class="code">代码内容</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">下面是HTML代码块</span><br><span class="line"></span><br><span class="line"><span class="code">```html</span></span><br><span class="line"><span class="code">&lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;row 1, cell 1&lt;/td&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;row 1, cell 2&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;row 2, cell 1&lt;/td&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;row 2, cell 2&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">下面是CSS代码块</span><br><span class="line"></span><br><span class="line"><span class="code">```css</span></span><br><span class="line"><span class="code">.box &#123;</span></span><br><span class="line"><span class="code">width: 600px;</span></span><br><span class="line"><span class="code">height: 400px;</span></span><br><span class="line"><span class="code">margin: 100px auto;</span></span><br><span class="line"><span class="code">background-image: linear-gradient(black 33.3%,red 33.3%, red 66.6%, yellow 66.6%, yellow);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">下面是JavaScript代码块</span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">    // 定义一个30个整数的数组，按顺序分别赋予从2开始的偶数；然后按顺序每五个数求出一个平均值，放在另一个数组中并输出。试编程</span></span><br><span class="line"><span class="code">    let arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60]</span></span><br><span class="line"><span class="code">    let newarr = [];</span></span><br><span class="line"><span class="code">    for (let i = 0, count = 0, sum = 0, len = arr.length; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="code">        sum += arr.shift();</span></span><br><span class="line"><span class="code">        count++;</span></span><br><span class="line"><span class="code">        if (count % 5 === 0) &#123;</span></span><br><span class="line"><span class="code">            newarr.push(sum / 5);</span></span><br><span class="line"><span class="code">            sum =  0;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    console.log(newarr);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    let arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60]</span></span><br><span class="line"><span class="code">    let newarr = [];</span></span><br><span class="line"><span class="code">    for (let i = 0, len = arr.length; i &lt; len / 5; i++) &#123;</span></span><br><span class="line"><span class="code">        let subarr = arr.splice(0, 5)</span></span><br><span class="line"><span class="code">        for (let j = 0, sum = 0; j &lt; subarr.length; j++) &#123;</span></span><br><span class="line"><span class="code">            sum += subarr[j];</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        newarr.push(sum / 5);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    console.log(newarr);</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面是Python代码块</span><br><span class="line"></span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">#!/usr/bin/python</span></span><br><span class="line"><span class="code"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">i = 2</span></span><br><span class="line"><span class="code">while(i &lt; 100):</span></span><br><span class="line"><span class="code">   j = 2</span></span><br><span class="line"><span class="code">   while(j &lt;= (i/j)):</span></span><br><span class="line"><span class="code">      if not(i%j): break</span></span><br><span class="line"><span class="code">      j = j + 1</span></span><br><span class="line"><span class="code">   if (j &gt; i/j) : print i, &quot; 是素数&quot;</span></span><br><span class="line"><span class="code">   i = i + 1</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">print &quot;Good bye!&quot;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">下面是一块突出显示的文本</span><br><span class="line"></span><br><span class="line"><span class="code">```txt</span></span><br><span class="line"><span class="code">这是一段</span></span><br><span class="line"><span class="code">突出显示的</span></span><br><span class="line"><span class="code">文本内容</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><h4 id="示范-19"><a href="#示范-19" class="headerlink" title="示范"></a>示范</h4> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(black <span class="number">33.3%</span>, red <span class="number">33.3%</span>, red <span class="number">66.6%</span>, yellow <span class="number">66.6%</span>, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个30个整数的数组，按顺序分别赋予从2开始的偶数；然后按顺序每五个数求出一个平均值，放在另一个数组中并输出。试编程</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">42</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">48</span>, <span class="number">50</span>, <span class="number">52</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">58</span>, <span class="number">60</span>]</span><br><span class="line"><span class="keyword">let</span> newarr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, count = <span class="number">0</span>, sum = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">sum += arr.<span class="title function_">shift</span>();</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">newarr.<span class="title function_">push</span>(sum / <span class="number">5</span>);</span><br><span class="line">sum =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newarr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">42</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">48</span>, <span class="number">50</span>, <span class="number">52</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">58</span>, <span class="number">60</span>]</span><br><span class="line"><span class="keyword">let</span> newarr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len / <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> subarr = arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, sum = <span class="number">0</span>; j &lt; subarr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">sum += subarr[j];</span><br><span class="line">&#125;</span><br><span class="line">newarr.<span class="title function_">push</span>(sum / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newarr);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">100</span>):</span><br><span class="line">   j = <span class="number">2</span></span><br><span class="line">   <span class="keyword">while</span>(j &lt;= (i/j)):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span>(i%j): <span class="keyword">break</span></span><br><span class="line">      j = j + <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> (j &gt; i/j) : <span class="built_in">print</span> i, <span class="string">&quot; 是素数&quot;</span></span><br><span class="line">   i = i + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Good bye!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一段</span><br><span class="line">突出显示的</span><br><span class="line">文本内容</span><br></pre></td></tr></table></figure><br><h4 id="7-2-1-代码块的嵌套"><a href="#7-2-1-代码块的嵌套" class="headerlink" title="7.2.1 代码块的嵌套"></a>7.2.1 代码块的嵌套</h4><br><p><strong>格式：</strong></p><ul><li>使用<strong>4</strong>个 <code>`</code>  包裹 **3**个 <code>`</code></li></ul><h5 id="示范-20"><a href="#示范-20" class="headerlink" title="示范"></a>示范</h5><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">````txt</span></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">// 3. 输出 100以内(不包括100) 所有偶数的和</span></span><br><span class="line"><span class="code">// 这类求和问题的核心 ： 利用循环  (总和 = 旧数的和 + 新数)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">let sum = 0;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">for (let i = 1, sum = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="code"> if (i % 2 == 0) &#123;</span></span><br><span class="line"><span class="code"> // 筛选偶数</span></span><br><span class="line"><span class="code"> sum += i; // sum = sum + i // 累加偶数并赋值给sum</span></span><br><span class="line"><span class="code"> // sum为(旧的，已经进入循环的数)的和，i 为新进入循环的数。当加到(最后一个新数i)时，sum就是最后的 总和</span></span><br><span class="line"><span class="code"> &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">console.log(sum); // 打印总和</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">````</span></span><br></pre></td></tr></table></figure><br><p>如果要再套一层，就在最外层 加 <strong>5</strong>个 <code>`</code> ，以此类推……</p><br><h3 id="7-3-如何在行内代码里显示反引号"><a href="#7-3-如何在行内代码里显示反引号" class="headerlink" title="7.3 如何在行内代码里显示反引号"></a>7.3 如何在行内代码里显示反引号</h3><p>首尾各用 两个反引号<code>`</code>+ <code>空格</code> 包裹</p><p><strong>格式：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">``+空格+带`</span>的内容+空格+``  &lt;!-- 不要忘记前后的两个空格 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="code">`` 这是一段能显示`</span>反引号<span class="code">`的行内代码 `</span>`</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><code>这是一段能显示`反引号`的行内代码</code></p><p><br><br></p><h2 id="8-任务列表（待办）"><a href="#8-任务列表（待办）" class="headerlink" title="8. 任务列表（待办）"></a>8. 任务列表（待办）</h2><ul><li><p><strong>任务列表 的格式：</strong></p><ul><li><strong><kbd>-</kbd></strong> + <strong><kbd>空格</kbd></strong> +<strong><code>[ ]</code></strong> +<strong><kbd>空格</kbd></strong> + 任务列表内容    ( 中括号<code>[ ]</code> 里面必须有个空格)</li><li>给待办任务列表打 <strong><code>√</code></strong> ，变成 <strong>已办</strong><ol><li>在渲染界面，直接鼠标左键点击框框</li><li>在源代码界面，在中括号内输入 <strong>英文字母x</strong><ul><li>部分编辑器，在 中括号内 输入<strong>任意字符</strong>都可以打 <strong><code>√</code></strong>   ( 例如 <strong>Obsidian</strong> )</li></ul></li></ol></li></ul></li><li><p><strong>补充：</strong></p><ul><li>大部分 MD编辑器  支持输入第一个任务列表后，按下 <strong><kbd>Enter</kbd></strong> 进入下一行会 <strong>自动补全待办格式</strong></li><li>在<strong>Obsidian</strong>中，连续输入<strong>两次</strong> <code>Ctrl + Enter</code>  ，即可生成一个待办列表<ul><li>再输入一次 <code>Ctrl + Enter</code>  ，会在待办列表 打 <strong><code>√</code></strong></li></ul></li></ul></li><li><p><strong>格式：</strong></p></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 待办任务列表1</span><br><span class="line"><span class="bullet">-</span> [ ] 待办任务列表2</span><br><span class="line"><span class="bullet">-</span> [x] 已办任务列表1    &lt;!-- 英文字母X --&gt;</span><br><span class="line"><span class="bullet">-</span> [x] 已办任务列表2</span><br></pre></td></tr></table></figure><h3 id="示范-21"><a href="#示范-21" class="headerlink" title="示范"></a>示范</h3><ul><li><input disabled="" type="checkbox"> 待办任务列表1</li><li><input disabled="" type="checkbox"> 待办任务列表2</li><li><input checked="" disabled="" type="checkbox"> 已办任务列表1  </li><li><input checked="" disabled="" type="checkbox"> 已办任务列表2</li></ul><br>  <ul><li>在 <strong>Obsidian</strong> 中，可以利用 <strong><kbd>Ctrl</kbd></strong> + <strong><kbd>Enter</kbd></strong> ，快速生成任务列表<ol><li><strong><code>-</code></strong> + <strong><kbd>空格</kbd></strong> + <strong><kbd>Ctrl</kbd></strong> + <strong><kbd>Enter</kbd></strong>  +待办文本内容</li><li>待办文本内容 + <strong><kbd>Ctrl</kbd></strong> + <strong><kbd>Enter</kbd></strong> <strong>×2</strong>   &nbsp;&nbsp;( 输入文本后，连续2次 <code>Ctrl + enter</code> )</li></ol></li></ul><br><ul><li><strong>任务列表也是可以缩进+退格的，操作跟 无序、有序列表一样</strong></li></ul><h3 id="示范-22"><a href="#示范-22" class="headerlink" title="示范"></a>示范</h3><ul><li><input disabled="" type="checkbox"> 第一级待办列表1<ul><li><input disabled="" type="checkbox"> 第二级待办列表1<br>另起一行的第二级待办列表1<ul><li><input checked="" disabled="" type="checkbox"> 第三级已办列表1</li><li><input checked="" disabled="" type="checkbox"> 第三级已办列表2</li></ul></li><li><input disabled="" type="checkbox"> 第二级待办列表2<br>另起一行的第二级待办列表2</li></ul></li><li><input disabled="" type="checkbox"> 第一级待办列表2</li></ul><p><br> <br></p><h2 id="9-注释"><a href="#9-注释" class="headerlink" title="9. 注释"></a>9. 注释</h2><p><strong>Markdown</strong> 的 <strong>注释</strong> 和 <strong>HMTL</strong> 一样，注释的内容在 <strong>渲染界面</strong> <strong>不可见</strong> （部分编辑器可见)</p><ul><li><strong>注释 的格式：</strong><ul><li><code>&lt;!-- 这里是注释的内容 --&gt;</code><ul><li>注释可以是单行，也可以是多行</li></ul></li><li>如果有在使用 <strong>Obsidian</strong> 的，它的注释格式是不一样的<ul><li><strong><code>%%这是Obsidian的注释内容%%</code></strong></li></ul></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这里是一行注释 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">这里是</span><br><span class="line">一段</span><br><span class="line">假装有</span><br><span class="line">很多行的</span><br><span class="line">注释</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">%%这是一行Obsidian里的注释%%</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">这里是</span><br><span class="line">一段</span><br><span class="line">假装有</span><br><span class="line">很多行的</span><br><span class="line">Obsidian里的</span><br><span class="line">注释</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><h3 id="示范-只有切换至-编辑模式-才能看到喔"><a href="#示范-只有切换至-编辑模式-才能看到喔" class="headerlink" title="示范 (只有切换至 编辑模式 才能看到喔) "></a>示范 <small>(只有切换至 编辑模式 才能看到喔) </small></h3><!-- 这里是一行注释 --><!--这里是一段假装有很多行的注释--><p>%%这是一行Obsidian里的注释%%</p><p>%%<br>这里是<br>一段<br>假装有<br>很多行的<br>Obsidian里的<br>注释<br>%%</p><p><br><br></p><h2 id="10-变量"><a href="#10-变量" class="headerlink" title="10. 变量"></a>10. 变量</h2><br><h3 id="10-1-网页链接变量"><a href="#10-1-网页链接变量" class="headerlink" title="10.1 网页链接变量"></a>10.1 网页链接变量</h3><ul><li><strong>网页链接变量 的格式：</strong><ol><li>首先输入 <ul><li><strong><code>[显示文本内容]</code></strong> + <strong><code>[变量名]</code></strong>    <ul><li>变量名可以自己取，没啥限制，任意字符都可以</li></ul></li></ul></li><li>在文档任意一个区域，输入：<ul><li><strong><code>[变量名]</code></strong> + <strong><kbd>:</kbd></strong> + <strong><kbd>空格</kbd></strong> + 链接地址   （这个**<kbd>空格</kbd>** 不打也没事)</li></ul></li></ol></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度一下，你就知道</span>][<span class="symbol">度娘</span>]</span><br><span class="line">[<span class="string">知乎-有问题，就会有答案</span>][<span class="symbol">知乎</span>]</span><br><span class="line"></span><br><span class="line">&lt;!-- 这里是变量区域 --&gt;</span><br><span class="line">[<span class="symbol">度娘</span>]: <span class="link">http://www.baidu.com </span></span><br><span class="line">[<span class="symbol">知乎</span>]: <span class="link">https://www.zhihu.com    </span></span><br></pre></td></tr></table></figure><h4 id="示范-23"><a href="#示范-23" class="headerlink" title="示范"></a>示范</h4><p><a href="http://www.baidu.com/">百度一下，你就知道</a></p><p><a href="https://www.zhihu.com/">知乎-有问题，就会有答案</a></p><br><h3 id="10-2-脚注"><a href="#10-2-脚注" class="headerlink" title="10.2 脚注"></a>10.2 脚注</h3><ul><li><strong>脚注 的格式：</strong><ul><li>在需要脚注的地方，输入：<ul><li><strong><code>[^脚注代号]</code></strong>   ( 脚注代号会直接显示在渲染界面 )<ul><li>脚注代号可以随便命名，不过推荐使用 <strong>数字序号</strong></li></ul></li></ul></li><li>在其他区域，输入：<ul><li><strong><code>[^脚注代号]</code></strong> + <strong><kbd>:</kbd></strong> + <strong><kbd>空格</kbd></strong> + 脚注内容   （这个 <strong><kbd>空格</kbd></strong> 不打也没事)</li></ul></li></ul></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">鲁迅原名是什么[^1] ，浙江哪里人[^2]</span><br><span class="line"></span><br><span class="line">&lt;!-- 这里是变量区域 --&gt;</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">周树人</span></span><br><span class="line">[<span class="symbol">^2</span>]: <span class="link">绍兴人</span></span><br></pre></td></tr></table></figure><h4 id="示范-24"><a href="#示范-24" class="headerlink" title="示范"></a>示范</h4><p>鲁迅原名是什么<a href="%E5%91%A8%E6%A0%91%E4%BA%BA">^1</a>，浙江哪里人<a href="%E7%BB%8D%E5%85%B4%E4%BA%BA">^2</a></p><p><br><br></p><h2 id="11-拓展文本格式标记"><a href="#11-拓展文本格式标记" class="headerlink" title="11. 拓展文本格式标记"></a>11. 拓展文本格式标记</h2><ul><li><strong>Markdown</strong> 想实现更多的文本显示效果，只能依赖HTML标记实现</li><li>个人<strong>不是很推荐</strong>在 MD 中使用 HTML，不过一些简单的标记还是可以 <strong>轻度使用</strong> 的</li></ul><br><h3 id="11-1-键盘文本"><a href="#11-1-键盘文本" class="headerlink" title="11.1 键盘文本"></a>11.1 键盘文本</h3><ul><li><p><strong>键盘文本的 格式：</strong></p><ul><li><strong><code>&lt;kbd&gt;键盘文本&lt;/kbd&gt;</code></strong></li><li><strong><code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;X&lt;/kbd&gt;</code></strong></li></ul></li><li><p><strong>效果：</strong></p><ul><li><strong><kbd>键盘文本</kbd></strong></li><li><strong><kbd>Ctrl</kbd></strong> + <strong><kbd>X</kbd></strong>    ( 剪切 )</li></ul></li><li><p><strong>说明：</strong></p><ul><li>键盘文本也不一定非得是键盘按键，也可以作为<strong>着重文本</strong>突出显示<ul><li><strong>效果：</strong> <kbd>这也算一种着重文本的方式</kbd></li></ul></li></ul></li></ul><h4 id="11-1-1-加粗键盘文本"><a href="#11-1-1-加粗键盘文本" class="headerlink" title="11.1.1 加粗键盘文本"></a>11.1.1 加粗键盘文本</h4><ul><li><p><strong>加粗</strong>键盘文本的格式有<strong>两种</strong>：</p><ul><li><code>&lt;kbd&gt;**键盘文本**&lt;/kbd&gt;</code></li><li><code>**&lt;kbd&gt;ctrl + x&lt;/kbd&gt;**</code></li></ul></li><li><p><strong>效果：</strong></p><ol><li><kbd><strong>键盘文本</strong></kbd></li><li><strong><kbd>ctrl + x</kbd></strong></li></ol></li></ul><br><h3 id="11-2-放大文本"><a href="#11-2-放大文本" class="headerlink" title="11.2 放大文本"></a>11.2 放大文本</h3><ul><li><p><strong>放大文本 的格式：</strong></p><ul><li><strong><code>这是一段普通文本</code></strong><br><code>&lt;big&gt;这是一段放大文本&lt;/big&gt;</code></li></ul></li><li><p><strong>效果：</strong></p><ul><li>这是一段普通文本<br><big>这是一段放大文本</big></li></ul></li></ul><h4 id="11-2-1-放大粗体文本"><a href="#11-2-1-放大粗体文本" class="headerlink" title="11.2.1 放大粗体文本"></a>11.2.1 放大粗体文本</h4><ul><li>放大<strong>加粗</strong>文本的格式有<strong>两种</strong>：<ol><li><code>**&lt;big&gt;这是一段放大粗体文本&lt;/big&gt;**</code></li><li><code>&lt;big&gt;**这是一段放大粗体文本**&lt;/big&gt;</code></li></ol></li><li><strong>效果：</strong><ol><li><strong><big>这是一段放大粗体文本</big></strong></li><li><big><strong>这是一段放大粗体文本</strong></big></li></ol></li></ul><br><h3 id="11-3-缩小文本"><a href="#11-3-缩小文本" class="headerlink" title="11.3 缩小文本"></a>11.3 缩小文本</h3><ul><li><strong>缩小文本 的格式：</strong><ul><li><strong><code>这是一段普通文本</code></strong><br><strong><code>&lt;small&gt;这是一段缩小文本&lt;/small&gt;</code></strong></li></ul></li><li><strong>效果：</strong><ul><li>这是一段普通文本<br><small>这是一段缩小文本</small></li></ul></li></ul><h4 id="11-3-1-缩小斜体文本"><a href="#11-3-1-缩小斜体文本" class="headerlink" title="11.3.1 缩小斜体文本"></a>11.3.1 缩小斜体文本</h4><ul><li><strong>斜体</strong>缩小文本 的格式有<strong>两种</strong>：<ol><li><code>&lt;small&gt;*这是一段缩小斜体文本*&lt;/small&gt;</code></li><li><code>*&lt;small&gt;这是一段缩小斜体文本&lt;/small&gt;*</code></li></ol></li><li><strong>效果：</strong><ol><li><small><em>这是一段缩小斜体文本</em></small></li><li><em><small>这是一段缩小斜体文本</small></em></li></ol></li></ul><br><h3 id="11-4-多彩文本"><a href="#11-4-多彩文本" class="headerlink" title="11.4 多彩文本"></a>11.4 多彩文本</h3><ul><li><strong>多彩文本 的格式：</strong><ul><li><strong><code>&lt;font color=orange&gt;这是一段橘色文本&lt;/font&gt;</code></strong></li></ul></li><li><strong>效果：</strong><ul><li><font color=orange>这是一段橘色文本</font><ul><li>color 里的颜色支持 英文单词，**<a href="http://c.runoob.com/front-end/55" title="可跳转至菜鸟教程了解">16进制</a>，<a href="https://www.runoob.com/cssref/func-rgb-css.html" title="可跳转至菜鸟教程了解">rgb</a>，<a href="https://www.runoob.com/cssref/func-rgba.html" title="可跳转至菜鸟教程了解">rgba</a>**</li></ul></li></ul></li></ul><br><h4 id="11-4-1-多彩粗体文本"><a href="#11-4-1-多彩粗体文本" class="headerlink" title="11.4.1 多彩粗体文本"></a>11.4.1 多彩粗体文本</h4><ul><li>只需要在上面示例的基础上，加上 <strong>加粗标识符</strong>，有<strong>两种</strong>格式：<ol><li><strong>格式1：</strong> <code>**&lt;font color=teal&gt;这是一段加粗的水鸭色文本&lt;/font&gt;**</code><ul><li><strong>效果：</strong>  <strong><font color=teal>这是一段加粗的水鸭色文本</font></strong></li></ul></li><li><strong>格式2：</strong> <code>&lt;font color=teal&gt;**这是一段加粗的水鸭色文本**&lt;/font&gt;</code><ul><li><strong>效果：</strong>  <font color=teal><strong>这是一段加粗的水鸭色文本</strong></font></li></ul></li></ol></li><li>若上述混搭方法的样式<strong>失效</strong> ，可以使用 纯HTML标记<ul><li><strong>格式：</strong> <code>&lt;strong style=&quot;color:teal;&quot;&gt;这是一段加粗的水鸭色文本&lt;/strong&gt;</code>   (标记略复杂，不是很推荐)</li><li><strong>效果：</strong> <strong style="color:teal;">这是一段加粗的水鸭色文本</strong></li></ul></li></ul><br><h4 id="11-4-2-多彩斜体文本"><a href="#11-4-2-多彩斜体文本" class="headerlink" title="11.4.2 多彩斜体文本"></a>11.4.2 多彩斜体文本</h4><ul><li>跟多彩加粗文本完全一样，只需把首尾的 <code>**</code> 换成 <code>*</code> 即可</li></ul><ol><li><strong>格式1：</strong> <code>*&lt;font color=teal&gt;This is an italic teal text&lt;/font&gt;*</code><ul><li><strong>效果：</strong>  <em><font color=teal>This is an italic teal text</font></em></li></ul></li><li><strong>格式2：</strong> <code>&lt;font color=teal&gt;*This is an italic teal text*&lt;/font&gt;</code><ul><li><strong>效果：</strong> <font color=teal><em>This is an italic teal text</em></font></li></ul></li></ol><br><h4 id="11-4-2-多彩粗斜体文本"><a href="#11-4-2-多彩粗斜体文本" class="headerlink" title="11.4.2 多彩粗斜体文本"></a>11.4.2 多彩粗斜体文本</h4><ul><li>首尾换成 <code>***</code></li></ul><ol><li><strong>格式1：</strong>  <code>***&lt;font color=teal&gt;This is a bold italic teal text&lt;/font&gt;***</code><ul><li><strong>效果：</strong>  <em><strong><font color=teal>This is a bold italic teal text</font></strong></em></li></ul></li><li><strong>格式2：</strong> <code>&lt;font color=teal&gt;***This is a bold italic teal text***&lt;/font&gt;</code><ul><li><strong>效果：</strong> <font color=teal><em><strong>This is a bold italic teal text</strong></em></font></li></ul></li></ol><br><p>#注意  多彩文本尽量慎用，<strong>Markdown</strong> 的核心就是 <strong>简洁精炼</strong>，注重 <strong>实质内容</strong>，而非花哨的 颜色样式</p><p><br><br></p><h2 id="12-拓展文本显示效果"><a href="#12-拓展文本显示效果" class="headerlink" title="12. 拓展文本显示效果"></a>12. 拓展文本显示效果</h2><ul><li>拓展显示效果既不是原生 <strong>Markdown语法</strong> 支持的，也非 HTML标记，而是部分编辑器 提供的 <strong>额外标识符</strong>，属于拓展语法，旨在为 <strong>Markdown使用者</strong> 提供更多样式选择</li><li>不同编辑器，支持不一样，这里以 <strong>Typora编辑器</strong> 为例</li></ul><br><h3 id="12-1-文本高亮"><a href="#12-1-文本高亮" class="headerlink" title="12.1 文本高亮"></a>12.1 文本高亮</h3><ul><li><strong>文本高亮 的格式：</strong><ul><li><strong><code>==这里是一段高亮文本==</code></strong></li></ul></li><li><strong>效果：</strong><ul><li>&#x3D;&#x3D;这里是一段高亮文本&#x3D;&#x3D;</li></ul></li></ul><br><h3 id="12-2-上标"><a href="#12-2-上标" class="headerlink" title="12.2 上标"></a>12.2 上标</h3><ul><li>用一对 <strong><kbd>^</kbd></strong> 包裹     (<strong><kbd>Shift</kbd>+ <kbd>6</kbd></strong>)<ul><li><strong>格式：</strong> <strong><code>x^2^</code></strong></li><li><strong>效果：</strong> x^2^</li></ul></li><li><strong>Obsidian</strong> 没效果的，可以用后面会讲的 <strong>Latex</strong></li><li>或者，也可以使用 <strong>HTML标记</strong><ul><li><code>&lt;sup&gt;这里是上标内容&lt;/sup&gt;</code></li><li><code>X&lt;sup&gt;2&lt;/sup&gt;</code></li></ul></li><li><strong>效果：</strong><ul><li><strong>X<sup>2</sup></strong></li></ul></li></ul><br><h3 id="12-3-下标"><a href="#12-3-下标" class="headerlink" title="12.3 下标"></a>12.3 下标</h3><ul><li>用一对 <strong><kbd>~</kbd></strong> 包裹    (<strong><kbd>Shift</kbd> + <kbd>`</kbd></strong>)<ul><li><strong>格式：</strong> <strong><code>H~2~O</code></strong></li><li><strong>效果：</strong> H<del>2</del>O</li></ul></li><li><strong>Obsidian</strong> 没效果的，可以用后面会讲的 <strong>Latex</strong></li><li>或者，也可以使用 <strong>HTML标记</strong><ul><li><code>&lt;sub&gt;这里是下标内容&lt;/sub&gt;</code></li><li><code>H&lt;sub&gt;2&lt;/sub&gt;O</code></li></ul></li><li><strong>效果：</strong><ul><li><strong>H<sub>2</sub>O</strong></li></ul></li></ul><br><h3 id="12-4-Emoji-符号"><a href="#12-4-Emoji-符号" class="headerlink" title="12.4 Emoji 符号"></a>12.4 Emoji 符号</h3><p>用一对 <kbd>:</kbd>  包裹，里面是 <strong>Emoji</strong> 符号的 <strong>语义化文本</strong>  ( <strong>Typora编辑器</strong> 中，输入 <code>:</code> 就会带提示器 )</p><ul><li><strong>示例：</strong><ul><li><code>:smile:</code><br><code>:sweat:</code><br><code>:cat:</code><br><code>:woman_cartwheeling:</code></li></ul></li><li><strong>效果：</strong><ul><li>:smile:<br>:sweat:<br>:cat:<br>:woman_cartwheeling:</li></ul></li></ul><br><ul><li><strong>补充：</strong><ul><li>不支持上述方式的 MD编辑器或笔记软件，直接用 <strong>输入法</strong> 输入也是可以的</li><li><strong>Windows系统</strong> 用户   <strong><kbd>win</kbd> + <kbd>.</kbd></strong>   就可以输入 Emoji 了</li><li><strong>Obsidian</strong> 用户可以安装<strong>第三方插件</strong>来支持 <strong>Emoji</strong> 的输入，推荐两个<ol><li>&#x3D;&#x3D;Emoji Shortcodes&#x3D;&#x3D;</li><li>&#x3D;&#x3D;Emoji Toolbar&#x3D;&#x3D;</li></ol></li></ul></li></ul><p><br><br></p><h2 id="13-转义字符"><a href="#13-转义字符" class="headerlink" title="13. 转义字符"></a>13. 转义字符</h2><ul><li>在 <strong>Markdown</strong> 中，我们 通过 <strong>标识符</strong> 改变 <strong>文本显示效果</strong></li><li>现在我们希望它不作为标识符，而是 <strong>作为字符本身呈现出来</strong> （不具备改变文本显示效果的功能，只是一个<strong>普通字符</strong>)<ul><li>首先我们可以用前面介绍的 <strong>代码域</strong> ，因为代码模式的显示效果就是源代码<strong>完全一致</strong>的</li><li>还有一种方法，可以利用转义字符，在这些标识符 <strong>前面</strong> 加上 <strong>反斜线</strong>  <strong><kbd>\</kbd></strong>   ( 反斜线要紧贴在标识符前面，<strong>不能</strong> 有 <strong><kbd>空格</kbd></strong> )<ul><li><strong>原理：</strong>  <ul><li><strong><code>\</code></strong>   的作用是让标识符 <strong>转义</strong> 变为一个<strong>普通字符</strong>，完成这个效果后，反斜线会<strong>自动隐藏</strong></li><li>隐藏后的反斜线仅在<strong>源代码</strong>界面<strong>可见</strong>，在<strong>渲染</strong>界面<strong>不可见</strong></li><li>反斜线只<strong>争对标识符</strong>起作用，其他字符添加 <strong><code>\</code><strong>，</strong><code>\</code></strong> 不会自动隐藏</li></ul></li><li><strong>补充：</strong><ul><li>如果想给已经被加在标识符前面，会自动隐藏的 <strong><code>\</code></strong> 显示出来，可以在反斜线前面再加一个 <strong><kbd>\</kbd></strong> ，用它<strong>自己来转义自己</strong><ul><li><strong>示例：</strong> <strong><code>这里紧跟在标识符前面的反斜线\\*会被转义成普通字符显示出来，不会自动隐藏，且这段文件会是斜体*</code></strong></li><li>*<em>效果： **  这里紧跟在标识符前面的 反斜线\</em>会被转义成普通字符显示出来，不会自动隐藏，且这段文件会是斜体*</li></ul></li></ul></li></ul></li></ul></li></ul><br><h3 id="例1-以普通字符显示星号"><a href="#例1-以普通字符显示星号" class="headerlink" title="例1 以普通字符显示星号"></a>例1 以普通字符显示星号</h3><ul><li>如何让被一对或多对 <strong><code>*</code></strong> 号 包裹的文本内容，能够正常显示 <strong><code>*</code></strong> ，且文本不改变格式<ul><li><code>\*这段文本被一对星号包裹，但不会倾斜\*</code><ul><li><strong>效果：</strong> *这段文本被1对星号包裹，但不会倾斜*</li></ul></li><li><code>\*\*这段文本被2对星号包裹，但不会加粗\*\*</code><ul><li><strong>效果：</strong> **这段文本被2对星号包裹，但不会加粗**</li></ul></li><li><code>\*\*\*这段文本被3对星号包裹，但它既不倾斜也不加粗\*\*\*</code><ul><li><strong>效果：</strong> ***这段文本被3对星号包裹，但它既不倾斜也不加粗***</li></ul></li></ul></li></ul><br><h3 id="例2-表格内-单元格中的竖杠"><a href="#例2-表格内-单元格中的竖杠" class="headerlink" title="例2 表格内 单元格中的竖杠"></a>例2 表格内 单元格中的竖杠</h3><ul><li>在表格中，使用 <strong><kbd>|</kbd></strong> 作为单元格的内容，但<strong>不会</strong>被识别为<strong>表格的结构</strong>，不会增加额外的单元格</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|表头1|表头2|</span><br><span class="line">|-|-|</span><br><span class="line">|这里的文本被\|分隔|这里的文本也被\|分隔|</span><br></pre></td></tr></table></figure><ul><li><strong>效果：</strong></li></ul><table><thead><tr><th align="center">表头1</th><th align="center">表头2</th></tr></thead><tbody><tr><td align="center">这里的文本被|分隔</td><td align="center">这里的文本也被|分隔</td></tr></tbody></table><br><p>#补充 该技巧可用于 <strong>Obsidian</strong>  表格内 双链的文本修饰</p><p><strong>文本修饰：</strong></p><p>在 双链<code>[[ ]]</code>内 以 <code>|</code> 引导的内容</p><ul><li><strong>格式：</strong> <code>[[链接的内容|文本修饰]]</code></li><li><strong>说明：</strong> 文本修饰是渲染界面实际显示的文本，便于更好地融入语境</li></ul><p><strong>表格内的格式：</strong></p><p>在 <code>|</code> 前面加上 <code>\</code></p><ul><li><code>[[表格内的链接内容\|文本修饰]]</code></li></ul><p><strong>示例：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|                  表头1                  |                        表头2                        |</span><br><span class="line">|:---------------------------------------:|:---------------------------------------------------:|</span><br><span class="line">| [[#例2 表格内 单元格中的竖杠\|单元格中的竖杠]] | [[#例3 不会变成代码的反引号\|不会变成代码的反引号]] |</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><table><thead><tr><th align="center">表头1</th><th align="center">表头2</th></tr></thead><tbody><tr><td align="center">[[#例2 表格内 单元格中的竖杠|单元格中的竖杠]]</td><td align="center">[[#例3 不会变成代码的反引号|不会变成代码的反引号]]</td></tr></tbody></table><br><h3 id="例3-不会变成代码的反引号"><a href="#例3-不会变成代码的反引号" class="headerlink" title="例3 不会变成代码的反引号"></a>例3 不会变成代码的反引号</h3><p>使用 转义符号<code>\</code> 让 反引号<code>`</code> 变成普通字符，不再具有[[#7 1 行内代码|行内代码]]的标识符功能</p><p><strong>格式：</strong></p><p><code>\`这段被反引号包裹的内容不会变成行内代码\`</code></p><p><strong>效果：</strong></p><p>`这段被反引号包裹的内容不会变成行内代码`</p><br><h3 id="例4-链接中的中括号"><a href="#例4-链接中的中括号" class="headerlink" title="例4 链接中的中括号"></a>例4 链接中的中括号</h3><p>在 <strong>网页链接</strong> 的 <strong>显示文本内容</strong> 中，使用 <strong>中括号</strong> <strong><code>[ ]</code></strong></p><ul><li>在显示文本内容中，在其中一个中括号前面，加上<strong>转义符号</strong> 反斜杠 <strong><kbd>\</kbd></strong><ul><li><strong>格式：</strong> <strong><code>[链接里的 \[中括号\] 能被正常显示](https://www.runoob.com)</code></strong></li><li><strong>效果：</strong> <a href="https://www.runoob.com/">链接里的 [中括号] 能被正常显示</a></li></ul></li></ul><br><h3 id="例5-不是列表的连接符-横杠"><a href="#例5-不是列表的连接符-横杠" class="headerlink" title="例5 不是列表的连接符(横杠)"></a>例5 不是列表的连接符(横杠)</h3><ul><li>引用一段话，一般会在换行之后，加上 <strong><code>- 出处</code></strong> </li><li>因为 <strong><kbd>-</kbd></strong> 是标识符，会变成一个无序列表</li></ul><p><strong>如下所示：</strong></p><blockquote><p>The Web, the Tree, and the String.<br>写作之难，在于把网状的思考，用树状结构，体现在线性展开的语句里。</p><ul><li>史蒂芬·平克</li></ul></blockquote><ul><li><p><strong>解决方法：</strong></p><ul><li>在 <strong><kbd>-</kbd></strong> 前面加上 转义符号  <strong><kbd>\</kbd></strong></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;The Web, the Tree, and the String.</span><br><span class="line">&gt;写作之难，在于把网状的思考，用树状结构，体现在线性展开的语句里。</span><br><span class="line">&gt;\- 史蒂芬·平克   &lt;!-- 加上转义符号 \ , 不会变成无序列表 --&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>效果：</strong></p></li></ul><blockquote><p>The Web, the Tree, and the String.<br>写作之难，在于把网状的思考，用树状结构，体现在线性展开的语句里。<br>- 史蒂芬·平克</p></blockquote><br><h3 id="例6-不是标题的"><a href="#例6-不是标题的" class="headerlink" title="例6 不是标题的 #"></a>例6 不是标题的 #</h3><p>让 <code>#</code> 不被识别为标题标识符</p><p><strong>格式：</strong></p><p><code>\# 这里的内容不会被识别为标题</code></p><p><strong>效果：</strong></p><p># 这里的内容不会被识别为标题</p><br><h3 id="例7-不会注释的"><a href="#例7-不会注释的" class="headerlink" title="例7 不会注释的 %"></a>例7 不会注释的 %</h3><p>在 <strong>Obsidian</strong> 中 注释是前后各两个 <code>%</code> 号</p><p>使用 转义符号<code>\</code>，让 <code>%%</code> 作为普通字符显示出来，不具备注释的功能</p><ul><li><strong>格式：</strong> <code>\%\%这里的内容可以被显示喔\%\%</code></li><li><strong>效果：</strong> %%这里的内容可以被显示喔%%</li></ul><br><h3 id="例8-木有链接的双链"><a href="#例8-木有链接的双链" class="headerlink" title="例8 木有链接的双链"></a>例8 木有链接的双链</h3><p><strong>Obsidian</strong> 的双向链格式是2个方括号 <code>[[ ]]</code> (双方)，使用 转义符号<code>\</code>，让 <code>[</code> <code>]</code> 不再具有 双链功能</p><p><strong>格式：</strong></p><p><code>\[\[这段文本被双方包裹，但不是一个双向链\]\]</code></p><p><strong>效果：</strong></p><p>[[这段文本被双方包裹，但不是一个双向链]]</p><br><h3 id="例9-页链接里-显示文本内的-中括号"><a href="#例9-页链接里-显示文本内的-中括号" class="headerlink" title="例9 页链接里 显示文本内的 中括号"></a>例9 页链接里 显示文本内的 中括号</h3><p>使用转义符号<code>\</code>，让<code>中括号</code>可以作为<code>显示文本</code> 在[[#5 1 网页链接|网页链接]]中显示出来</p><p><strong>格式：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">\[这是一个带中括号的网页链接显示文本，点击会跳转至百度\</span>]](https://www.baidu.com/)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><a href="https://www.baidu.com/">[这是一个带中括号的网页链接显示文本，点击会跳转至百度]</a></p><br><h3 id="特殊情况-文本修饰的中括号"><a href="#特殊情况-文本修饰的中括号" class="headerlink" title="特殊情况 文本修饰的中括号"></a>特殊情况 文本修饰的中括号</h3><p>文本修饰的 中括号<code>[ ]</code> <strong>不需要</strong>使用 转义符号<code>\</code></p><p><strong>示范：</strong></p><p><code>[[#例8 木有链接的双链|[这是一个带中括号的文本修饰]]]</code></p><p><strong>效果：</strong></p><p>[[#例8 木有链接的双链|[这是一个带中括号的文本修饰]]]</p><p><br><br></p><h2 id="14-空格-换行-强制删除"><a href="#14-空格-换行-强制删除" class="headerlink" title="14. 空格&amp;换行&amp;强制删除"></a>14. 空格&amp;换行&amp;强制删除</h2><br><h3 id="14-1-空格"><a href="#14-1-空格" class="headerlink" title="14.1 空格"></a>14.1 空格</h3><ul><li>在一些编辑器或者支持MD的笔记软件里，无论你打多少个<strong>空格</strong>，它只会显示单个 <strong>空格</strong> 的距离<ul><li>可以使用 HTML中 <strong>空格</strong> 的 <strong>字符实体</strong> ——  <strong><code>&amp;nbsp;</code></strong>  </li><li>若要添加 <strong>多个</strong> 空格，就输入多个 ——  <strong><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</code></strong></li></ul></li><li><strong>格式：</strong><ul><li><strong><code>这里有&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;6个空格分隔</code></strong></li></ul></li><li><strong>效果：</strong><ul><li>这里有&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6个空格分隔</li></ul></li></ul><br><h3 id="14-2-换行"><a href="#14-2-换行" class="headerlink" title="14.2 换行"></a>14.2 换行</h3><p><strong>场景1：</strong></p><ul><li>在一些编辑器或者支持MD的笔记软件里，无论你打多少个 <strong>回车</strong>，它只会显示单个 <strong>回车</strong> 的空行间距<ul><li>可以使用之前表格里提到的 <strong><code>&lt;br&gt;</code></strong> 标签，在 <strong>单独一行</strong> 中使用，增加额外的空行间距</li><li>如果要增加 <strong>多个</strong>，就输入 <strong>多个</strong> ——  <strong><code>&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</code></strong> </li><li>#注意 当单独一行使用 <code>&lt;br&gt;</code> 标签的时候，如果前后有标题标识符或者列表标识符，确保 <strong>br元素</strong> 前后两行都是空白行</li></ul></li></ul><p><strong>格式：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里是第一段文本</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>     &lt;!-- 这里插入了5个空行间距 --&gt;</span><br><span class="line"></span><br><span class="line">这里是第二段文本</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>这里是第一段文本</p><p><br><br><br><br><br></p><p>这里是第二段文本</p><p><br><br></p><p><strong>场景2：</strong></p><ul><li>在列表中也可以插入换行符</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 这是一段无序列表</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>     &lt;!-- 插入一个空行间距，需单独一行，上下不用预留空格 --&gt;</span><br><span class="line">  这是同一段无序列表中，空一行距离显示的内容</span><br><span class="line"><span class="bullet">-</span> 这是第二段无序列表</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>这里是第一段无序列表<br>这里是同一段无序列表中，空一行距离显示的内容</li><li>这里是第二段无序列表</li></ul><br><ul><li><strong>补充：</strong><ul><li>有一些MD编辑器或笔记软件，严格遵循MD的换行规则，你敲一个回车是没法换行的，必须在 <strong>行末</strong> 敲 <strong>2个空格</strong>，再按回车键<ul><li><strong>格式：</strong><ul><li>这里是一段想换行的文本<kbd>空格</kbd> <kbd>空格</kbd> <kbd>Enter</kbd><br>这是换行后的文本</li></ul></li></ul></li></ul></li></ul><br><h3 id="14-3-强制删除"><a href="#14-3-强制删除" class="headerlink" title="14.3 强制删除"></a>14.3 强制删除</h3><ul><li>很多编辑器都有英文标点自动补全功能，自动生成一对，光标落在中间<br>只想删除前面1个，却会把 <strong>一整对</strong> 都删掉</li><li>在多个列表的嵌套中，也许会遇到一些 <strong>无法被删除</strong> 的 <strong>列表标识符</strong></li><li><strong>解决方法：</strong><br>使用 <strong><code>Shift</code></strong> + <strong><code>Backspace</code></strong>  即可强制删除<ul><li><strong><kbd>Bcakspace</kbd></strong> &nbsp; ( 退格键 )</li></ul></li></ul><p><br><br></p><h2 id="15-嵌入"><a href="#15-嵌入" class="headerlink" title="15. 嵌入"></a>15. 嵌入</h2><ul><li>嵌入都是依赖 <strong>HTML标签</strong> 实现的，嵌入的都是<strong>在线</strong>链接格式<ul><li>如果是本地的，<strong>Obsidian</strong> 中音频是有自带的可录制的录音机插件的，其他的 <strong>音频、视频</strong> 直接复制黏贴就可以了，也可以直接拖拽到OB的笔记界面<ul><li>其他的媒体文件在 <strong>Obsidian</strong> 也和图片一样，以<strong>双链</strong>的格式引用在目标笔记中，使用 <strong><kbd>!</kbd></strong> 使它可见</li></ul></li></ul></li></ul><br><h3 id="15-1-嵌入音频"><a href="#15-1-嵌入音频" class="headerlink" title="15.1 嵌入音频"></a>15.1 嵌入音频</h3><ul><li><p><strong>格式：</strong></p><ul><li><strong><code>&lt;audio controls=&quot;controls&quot; preload=&quot;none&quot; src=&quot;音频链接地址&quot;&gt;&lt;/audio&gt;</code></strong></li></ul></li><li><p><strong>示例：</strong></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.ldoceonline.com/media/english/exaProns/p008-001803372.mp3?version=1.2.37&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>效果：</strong></li></ul><p><audio controls="controls" preload="none" src="https://www.ldoceonline.com/media/english/exaProns/p008-001803372.mp3?version=1.2.41"></audio></p><br><h3 id="15-2-嵌入视频"><a href="#15-2-嵌入视频" class="headerlink" title="15.2 嵌入视频"></a>15.2 嵌入视频</h3><ul><li><strong>格式：</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">height</span>=<span class="string">&quot;420&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明：</strong><ul><li>width ( 宽度 )   height ( 高度 ) ，可以自己设置，直接输入数字即可，单位默认是 px(像素)<br>也可以使用 <strong>百分比</strong><br><strong><code>width=100%</code></strong> 代表水平撑满整个窗口<br><strong><code>height=50%</code></strong> 代表垂直撑满半个窗口 </li><li><strong>Video标签</strong> 支持的视频格式 ：MP4  ogg  webm</li></ul></li></ul><br><h3 id="15-3-嵌入页面"><a href="#15-3-嵌入页面" class="headerlink" title="15.3 嵌入页面"></a>15.3 嵌入页面</h3><ul><li><strong>格式：</strong> <strong><code>&lt;iframe width=600 height=400 src=&quot;页面链接地址&quot; scrolling=&quot;auto&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></strong></li></ul> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">600</span> <span class="attr">height</span>=<span class="string">400</span> <span class="attr">src</span>=<span class="string">&quot;https://www.runoob.com/html/html-tutorial.html&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>效果：</strong></li></ul><iframe width=600 height=400 src="https://www.runoob.com/html/html-tutorial.html" scrolling="auto" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><ul><li><p><strong>iframe标签</strong>  除了嵌入页面，也可以嵌入<strong>在线视频</strong>，主流的视频网站都会提供<strong>嵌入代码</strong></p><ul><li>具体可以看这个 <a href="https://www.wolai.com/wolai/go85vJpt3wDwrid7DfCZcE">iframe视频嵌入教程</a></li><li><strong>B站</strong> 的视频，得在 <strong><code>//</code></strong> 前面补充  <strong><code>http:</code></strong></li><li>不是所有的 编辑器和笔记软件 都支持这个</li></ul></li><li><p><strong>示例：</strong></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">600</span> <span class="attr">height</span>=<span class="string">400</span> <span class="attr">src</span>=<span class="string">&quot;http://player.bilibili.com/player.html?aid=20190823&amp;bvid=BV1yW411s7og&amp;cid=32964980&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>宽高设置和前面的 <strong>video</strong> 一样</li></ul><br><ul><li><strong>效果：</strong></li></ul><iframe width=600 height=400 src="http://player.bilibili.com/player.html?aid=20190823&bvid=BV1yW411s7og&cid=32964980&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><br><br></p><h2 id="16-Latex-数学公式"><a href="#16-Latex-数学公式" class="headerlink" title="16. Latex 数学公式"></a>16. Latex 数学公式</h2><ul><li>主要用于 <strong>数学公式</strong> 与 <strong>化学公式</strong> 的书写</li></ul><br><h3 id="16-1-行内公式"><a href="#16-1-行内公式" class="headerlink" title="16.1 行内公式"></a>16.1 行内公式</h3><ul><li><p><strong>格式：</strong></p><ul><li><strong><kbd>$</kbd></strong> + 行内公式 + <strong><kbd>$</kbd></strong></li></ul></li></ul><br><ul><li><strong>示例：</strong><ul><li><strong><code>$x^2 + 2x + 5 + \sqrt x = 0$</code></strong></li><li><strong><code>$\ce&#123;CO2 + C -&gt; 2 CO&#125;$</code></strong></li><li><code>$\ce&#123;CO2 + C -&gt; 2 CO&#125;$</code></li><li><code>$\ce&#123;2Mg + O2 -&gt;[燃烧] 2 MgO&#125;$</code></li></ul></li></ul><br><ul><li><strong>效果：</strong><ul><li>$x^2 + 2x + 5 + \sqrt x &#x3D; 0$</li><li>$e^{i\pi} + 1 &#x3D; 0$</li><li>$\ce{CO2 + C -&gt; 2 CO}$</li><li>$\ce{2Mg + O2 -&gt;[燃烧] 2 MgO}$</li></ul></li></ul><br><h3 id="16-2-公式块"><a href="#16-2-公式块" class="headerlink" title="16.2 公式块"></a>16.2 公式块</h3><ul><li><strong>格式：</strong><ul><li><strong><code>$$</code></strong><br>公式块<br><strong><code>$$</code></strong></li></ul></li></ul><br><ul><li><strong>示例：</strong></li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 化学公式</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\ce</span>&#123;Zn<span class="built_in">^</span>2+  &lt;=&gt;[+ 2OH-][+ 2H+]  <span class="built_in">$</span><span class="keyword">\underset</span>&#123;<span class="keyword">\text</span>&#123;amphoteres Hydroxid&#125;&#125;&#123;<span class="keyword">\ce</span>&#123;Zn(OH)2 v&#125;&#125;<span class="built_in">$</span>  &lt;=&gt;[+ 2OH-][+ 2H+]  <span class="built_in">$</span><span class="keyword">\underset</span>&#123;<span class="keyword">\text</span>&#123;Hydroxozikat&#125;&#125;&#123;<span class="keyword">\ce</span>&#123;[Zn(OH)4]<span class="built_in">^</span>2-&#125;&#125;<span class="built_in">$</span>&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 麦克斯韦方程组</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;lll&#125;</span><br><span class="line"><span class="keyword">\nabla</span><span class="keyword">\times</span> E <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> -<span class="keyword">\;</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#123;B&#125;&#125;&#123;<span class="keyword">\partial</span>&#123;t&#125;&#125;   </span><br><span class="line"><span class="keyword">\ </span><span class="keyword">\nabla</span><span class="keyword">\times</span> H <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#123;D&#125;&#125;&#123;<span class="keyword">\partial</span>&#123;t&#125;&#125;+J   </span><br><span class="line"><span class="keyword">\ </span><span class="keyword">\nabla</span><span class="keyword">\cdot</span> D <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> <span class="keyword">\rho</span></span><br><span class="line"><span class="keyword">\ </span><span class="keyword">\nabla</span><span class="keyword">\cdot</span> B <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> 0</span><br><span class="line"><span class="keyword">\ </span><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 薛定谔方程</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">i<span class="keyword">\hbar</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> <span class="keyword">\psi</span>&#125;&#123;<span class="keyword">\partial</span> t&#125; = <span class="keyword">\frac</span>&#123;-<span class="keyword">\hbar</span><span class="built_in">^</span>2&#125;&#123;2m&#125; <span class="keyword">\left</span>(<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2&#125;&#123;<span class="keyword">\partial</span> x<span class="built_in">^</span>2&#125; + <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2&#125;&#123;<span class="keyword">\partial</span> y<span class="built_in">^</span>2&#125;+<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2&#125;&#123;<span class="keyword">\partial</span> z<span class="built_in">^</span>2&#125; <span class="keyword">\right</span>) <span class="keyword">\psi</span> + V <span class="keyword">\psi</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><br><ul><li><strong>效果：</strong></li></ul><p>$$<br>% 化学公式<br>\ce{Zn^2+  &lt;&#x3D;&gt;[+ 2OH-][+ 2H+]  $\underset{\text{amphoteres Hydroxid}}{\ce{Zn(OH)2 v}}$  &lt;&#x3D;&gt;[+ 2OH-][+ 2H+]  $\underset{\text{Hydroxozikat}}{\ce{[Zn(OH)4]^2-}}$}<br>$$</p><br><p>$$<br>% 麦克斯韦方程组<br>\begin{array}{lll}<br>\nabla\times E &amp;&#x3D;&amp; -;\frac{\partial{B}}{\partial{t}}<br>\ \nabla\times H &amp;&#x3D;&amp; \frac{\partial{D}}{\partial{t}}+J<br>\ \nabla\cdot D &amp;&#x3D;&amp; \rho<br>\ \nabla\cdot B &amp;&#x3D;&amp; 0<br>\ \end{array}<br>$$</p><br><p>$$<br>i\hbar\frac{\partial \psi}{\partial t} &#x3D; \frac{-\hbar^2}{2m} \left(\frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}+\frac{\partial^2}{\partial z^2} \right) \psi + V \psi<br>$$</p><ul><li><strong>补充：</strong><ul><li>需要详细教程的，可戳下方链接</li><li><a href="https://www.wolai.com/wolai/egjDbHiAfGfJmwR972fcEW">Latex详细教程</a></li></ul></li></ul><p><br><br></p><h2 id="17-Mermaid"><a href="#17-Mermaid" class="headerlink" title="17. Mermaid"></a>17. Mermaid</h2><ul><li><p>一些 <strong>MD编辑器</strong> 和 <strong>笔记软件</strong> 支持通过 <a href="https://mermaid-js.github.io/" title="Mermaid官网"><strong>Mermaid</strong></a> 及其所提供的 <a href="https://mermaid-js.github.io/mermaid-live-editor" title="Mermaid在线编译器">编译器</a> 来为用户提供图表的绘制功能</p></li><li><p>这里只提供一些演示的图表，具体教程可戳下方</p><ul><li>[[MOC Mermiad 教程 Obsidian版| Mermiad 超级教程 Obsidian版]]</li></ul></li></ul><br><h3 id="17-1-流程图"><a href="#17-1-流程图" class="headerlink" title="17.1 流程图"></a>17.1 流程图</h3><br><p><strong><big>源码1：</big></strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">graph TB</span><br><span class="line">%% s=start  e=end  f=fork  n=normal</span><br><span class="line"></span><br><span class="line">s([开始])--&gt;f1&#123;&#123;if条件&#125;&#125;;</span><br><span class="line"></span><br><span class="line">%% 分支点2</span><br><span class="line">f1--true--&gt;n1[if语句块]--&gt;e([结束]);</span><br><span class="line">f1--false--&gt;f2&#123;&#123;else if条件&#125;&#125;;</span><br><span class="line"></span><br><span class="line">%% 分支点1</span><br><span class="line">f2--true--&gt;n2[else if语句块]--&gt;e;</span><br><span class="line">f2--false--&gt;n3[else语句块]--&gt;e;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong><big>渲染1：</big></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">%% s=start  e=end  f=fork  n=normal</span><br><span class="line"></span><br><span class="line">s([开始])--&gt;f1&#123;&#123;if条件&#125;&#125;;</span><br><span class="line"></span><br><span class="line">%% 分支点1</span><br><span class="line">f1--true--&gt;n1[if语句块]--&gt;e([结束]);</span><br><span class="line">f1--false--&gt;f2&#123;&#123;else if条件&#125;&#125;;</span><br><span class="line"></span><br><span class="line">%% 分支点2 </span><br><span class="line">f2--true--&gt;n2[else if语句块]--&gt;e;</span><br><span class="line">f2--false--&gt;n3[else语句块]--&gt;e;</span><br></pre></td></tr></table></figure><br><p><strong><big>源码2：</big></strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">%% s=start  e=end  f= fork n=normal </span><br><span class="line"></span><br><span class="line">%% 虚线</span><br><span class="line">s[朱百六]-.-&gt;|子|n1[朱四九]-.-&gt;|子|n2[朱五四]-.-&gt;|子|f1_帝((朱八八))</span><br><span class="line"></span><br><span class="line">%% 分支点 朱八八</span><br><span class="line">f1_帝--&gt;|长子|f2[朱标]</span><br><span class="line">f1_帝--&gt;|次子|n3[朱樉]</span><br><span class="line">f1_帝--&gt;|三子|n4[朱棢]</span><br><span class="line">f1_帝--&gt;|四子|n5_帝((朱棣))</span><br><span class="line"></span><br><span class="line">%% 分支点 朱标</span><br><span class="line">f2--&gt;|长子|e1[朱雄英]</span><br><span class="line">f2--&gt;|次子|e2_帝((朱允炆))</span><br><span class="line"></span><br><span class="line">n5_帝--&gt;|长子|e3[朱高炽]</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong><big>渲染2：</big></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">%% s=start  e=end  f= fork n=normal </span><br><span class="line"></span><br><span class="line">%% 虚线</span><br><span class="line">s[朱百六]-.-&gt;|子|n1[朱四九]-.-&gt;|子|n2[朱五四]-.-&gt;|子|f1_帝((朱八八))</span><br><span class="line"></span><br><span class="line">%% 分支点 朱八八</span><br><span class="line">f1_帝--&gt;|长子|f2[朱标]</span><br><span class="line">f1_帝--&gt;|次子|n3[朱樉]</span><br><span class="line">f1_帝--&gt;|三子|n4[朱棢]</span><br><span class="line">f1_帝--&gt;|四子|n5_帝((朱棣))</span><br><span class="line"></span><br><span class="line">%% 分支点 朱标</span><br><span class="line">f2--&gt;|长子|e1[朱雄英]</span><br><span class="line">f2--&gt;|次子|e2_帝((朱允炆))</span><br><span class="line"></span><br><span class="line">n5_帝--&gt;|长子|e3[朱高炽]</span><br></pre></td></tr></table></figure><br><h3 id="17-2-饼图"><a href="#17-2-饼图" class="headerlink" title="17.2 饼图"></a>17.2 饼图</h3><br><p><strong><big>源码：</big></strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">pie</span></span><br><span class="line"><span class="code">    title 为什么总是宅在家里？</span></span><br><span class="line"><span class="code">    &quot;喜欢宅&quot; : 45</span></span><br><span class="line"><span class="code">    &quot;天气太热&quot; : 70</span></span><br><span class="line"><span class="code">    &quot;穷&quot; : 500</span></span><br><span class="line"><span class="code">&quot;关你屁事&quot; : 95</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p><strong><big>渲染：</big></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;喜欢宅&quot; : 45</span><br><span class="line">    &quot;天气太热&quot; : 70</span><br><span class="line">    &quot;穷&quot; : 500</span><br><span class="line">&quot;关你屁事&quot; : 95</span><br></pre></td></tr></table></figure><br><h3 id="17-3-序列图-时序图"><a href="#17-3-序列图-时序图" class="headerlink" title="17.3 序列图 (时序图)"></a>17.3 序列图 (时序图)</h3><br><p><strong><big>源码：</big></strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">%% 自动编号</span><br><span class="line">autonumber</span><br><span class="line">%% 定义参与者并取别名，aliases：别名</span><br><span class="line">        participant A as Aly</span><br><span class="line">        participant B as Bob</span><br><span class="line">        participant C as CofCai</span><br><span class="line">        %% 便签说明</span><br><span class="line">        Note left of A: 只复习了一部分</span><br><span class="line">        Note right of B: 没复习</span><br><span class="line">        Note over A,B: are contacting</span><br><span class="line">        </span><br><span class="line">        A-&gt;&gt;B: 明天是要考试吗？</span><br><span class="line">        B--&gt;&gt;A: 好像是的！</span><br><span class="line">        </span><br><span class="line">        %% 显示并行发生的动作，parallel：平行</span><br><span class="line">        %% par [action1]</span><br><span class="line">        rect rgb(0, 25, 155)</span><br><span class="line">            par askA</span><br><span class="line">                C --&gt;&gt; A:你复习好了吗？</span><br><span class="line">            and askB</span><br><span class="line">                C --&gt;&gt; B:你复习好了吗？</span><br><span class="line">            and self</span><br><span class="line">                C -&gt;&gt;C:我还没准备复习......</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        %% 背景高亮，提供一个有颜色的背景矩形</span><br><span class="line">        rect rgb(25, 55, 0)</span><br><span class="line">            loop 自问/Every min</span><br><span class="line">            %% &lt;br/&gt;可以换行</span><br><span class="line">            C -&gt;&gt; C:我什么时候&lt;br/&gt;开始复习呢？</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        %% 可选择路径</span><br><span class="line">        rect rgb(153, 83, 60)</span><br><span class="line">            alt is good</span><br><span class="line">                A -&gt;&gt; C:复习了一点</span><br><span class="line">            else is common</span><br><span class="line">                B -&gt;&gt; C:我也是</span><br><span class="line">            end</span><br><span class="line">            %% 没有else时可以提供默认的opt</span><br><span class="line">            opt Extra response</span><br><span class="line">                C -&gt;&gt; C:你们怎么不回答我</span><br><span class="line">            end</span><br><span class="line">        endsequenceDiagram</span><br><span class="line">%% 自动编号</span><br><span class="line">autonumber</span><br><span class="line">%% 定义参与者并取别名，aliases：别名</span><br><span class="line">        participant A as Aly</span><br><span class="line">        participant B as Bob</span><br><span class="line">        participant C as CofCai</span><br><span class="line">        %% 便签说明</span><br><span class="line">        Note left of A: 只复习了一部分</span><br><span class="line">        Note right of B: 没复习</span><br><span class="line">        Note over A,B: are contacting</span><br><span class="line">        </span><br><span class="line">        A-&gt;&gt;B: 明天是要考试吗？</span><br><span class="line">        B--&gt;&gt;A: 好像是的！</span><br><span class="line">        </span><br><span class="line">        %% 显示并行发生的动作，parallel：平行</span><br><span class="line">        %% par [action1]</span><br><span class="line">        rect rgb(0, 25, 155)</span><br><span class="line">            par askA</span><br><span class="line">                C --&gt;&gt; A:你复习好了吗？</span><br><span class="line">            and askB</span><br><span class="line">                C --&gt;&gt; B:你复习好了吗？</span><br><span class="line">            and self</span><br><span class="line">                C -&gt;&gt;C:我还没准备复习......</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        %% 背景高亮，提供一个有颜色的背景矩形</span><br><span class="line">        rect rgb(25, 55, 0)</span><br><span class="line">            loop 自问/Every min</span><br><span class="line">            %% &lt;br/&gt;可以换行</span><br><span class="line">            C -&gt;&gt; C:我什么时候&lt;br/&gt;开始复习呢？</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        %% 可选择路径</span><br><span class="line">        rect rgb(153, 83, 60)</span><br><span class="line">            alt is good</span><br><span class="line">                A -&gt;&gt; C:复习了一点</span><br><span class="line">            else is common</span><br><span class="line">                B -&gt;&gt; C:我也是</span><br><span class="line">            end</span><br><span class="line">            %% 没有else时可以提供默认的opt</span><br><span class="line">            opt Extra response</span><br><span class="line">                C -&gt;&gt; C:你们怎么不回答我</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong><big>渲染：</big></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">%% 自动编号</span><br><span class="line">autonumber</span><br><span class="line">%% 定义参与者并取别名，aliases：别名</span><br><span class="line">        participant A as Aly</span><br><span class="line">        participant B as Bob</span><br><span class="line">        participant C as CofCai</span><br><span class="line">        %% 便签说明</span><br><span class="line">        Note left of A: 只复习了一部分</span><br><span class="line">        Note right of B: 没复习</span><br><span class="line">        Note over A,B: are contacting</span><br><span class="line">        </span><br><span class="line">        A-&gt;&gt;B: 明天是要考试吗？</span><br><span class="line">        B--&gt;&gt;A: 好像是的！</span><br><span class="line">        </span><br><span class="line">        %% 显示并行发生的动作，parallel：平行</span><br><span class="line">        %% par [action1]</span><br><span class="line">        rect rgb(0, 25, 155)</span><br><span class="line">            par askA</span><br><span class="line">                C --&gt;&gt; A:你复习好了吗？</span><br><span class="line">            and askB</span><br><span class="line">                C --&gt;&gt; B:你复习好了吗？</span><br><span class="line">            and self</span><br><span class="line">                C -&gt;&gt;C:我还没准备复习......</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        %% 背景高亮，提供一个有颜色的背景矩形</span><br><span class="line">        rect rgb(25, 55, 0)</span><br><span class="line">            loop 自问/Every min</span><br><span class="line">            %% &lt;br/&gt;可以换行</span><br><span class="line">            C -&gt;&gt; C:我什么时候&lt;br/&gt;开始复习呢？</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        %% 可选择路径</span><br><span class="line">        rect rgb(153, 83, 60)</span><br><span class="line">            alt is good</span><br><span class="line">                A -&gt;&gt; C:复习了一点</span><br><span class="line">            else is common</span><br><span class="line">                B -&gt;&gt; C:我也是</span><br><span class="line">            end</span><br><span class="line">            %% 没有else时可以提供默认的opt</span><br><span class="line">            opt Extra response</span><br><span class="line">                C -&gt;&gt; C:你们怎么不回答我</span><br><span class="line">            end</span><br><span class="line">        end</span><br></pre></td></tr></table></figure><br><h3 id="17-4-甘特图"><a href="#17-4-甘特图" class="headerlink" title="17.4 甘特图"></a>17.4 甘特图</h3><br><p><strong><big>源码：</big></strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong><big>渲染：</big></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br></pre></td></tr></table></figure><h3 id="17-5-类图"><a href="#17-5-类图" class="headerlink" title="17.5 类图"></a>17.5 类图</h3><br><p><strong><big>源码：</big></strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">classDiagram</span></span><br><span class="line"><span class="code">    Animal &lt;|-- Duck</span></span><br><span class="line"><span class="code">    Animal &lt;|-- Fish</span></span><br><span class="line"><span class="code">    Animal &lt;|-- Zebra</span></span><br><span class="line"><span class="code">    Animal : +int age</span></span><br><span class="line"><span class="code">    Animal : +String gender</span></span><br><span class="line"><span class="code">    Animal: +isMammal()</span></span><br><span class="line"><span class="code">    Animal: +mate()</span></span><br><span class="line"><span class="code">    class Duck&#123;</span></span><br><span class="line"><span class="code">      +String beakColor</span></span><br><span class="line"><span class="code">      +swim()</span></span><br><span class="line"><span class="code">      +quack()</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    class Fish&#123;</span></span><br><span class="line"><span class="code">      -int sizeInFeet</span></span><br><span class="line"><span class="code">      -canEat()</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    class Zebra&#123;</span></span><br><span class="line"><span class="code">      +bool is_wild</span></span><br><span class="line"><span class="code">      +run()</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p><strong><big>渲染：</big></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    Animal &lt;|-- Duck</span><br><span class="line">    Animal &lt;|-- Fish</span><br><span class="line">    Animal &lt;|-- Zebra</span><br><span class="line">    Animal : +int age</span><br><span class="line">    Animal : +String gender</span><br><span class="line">    Animal: +isMammal()</span><br><span class="line">    Animal: +mate()</span><br><span class="line">    class Duck&#123;</span><br><span class="line">      +String beakColor</span><br><span class="line">      +swim()</span><br><span class="line">      +quack()</span><br><span class="line">    &#125;</span><br><span class="line">    class Fish&#123;</span><br><span class="line">      -int sizeInFeet</span><br><span class="line">      -canEat()</span><br><span class="line">    &#125;</span><br><span class="line">    class Zebra&#123;</span><br><span class="line">      +bool is_wild</span><br><span class="line">      +run()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="18-标签-Tag"><a href="#18-标签-Tag" class="headerlink" title="18. 标签 (Tag)"></a>18. 标签 (Tag)</h2><ul><li>标签是 <strong>Obsidian</strong> 特有的一个功能，标签可以通过点击唤起快速搜索 (搜索包含该标签的所有笔记)</li></ul><p><strong>格式：</strong></p><ul><li><strong>#</strong> + <strong>标签名</strong> <ul><li><code>#标签名</code></li></ul></li></ul><h3 id="关于空格"><a href="#关于空格" class="headerlink" title="关于空格"></a>关于空格</h3><ul><li>在一段正文文本的后面添加 Tag， <kbd><strong>#</strong></kbd> 的<strong>前面</strong> 需要有个空格<ul><li><kbd><strong>空格</strong></kbd> + <strong>#</strong> + 标签名</li></ul></li></ul><br><ul><li># 与 标签名 <strong>之间</strong>，<strong>不能</strong>有空格，否则就变成 一级标题 了</li></ul><br><ul><li>标签名的<strong>内部</strong>，<strong>不允许</strong>使用空格，若想区分标签中的词语，可使用以下<strong>三种</strong>方法：<ol><li>驼峰式大小写： <code>#BlueTopaz</code></li><li>下划线： <code>#blue_topaz</code></li><li>连字符： <code>#blue-topaz</code></li></ol></li></ul><br><h3 id="关于数字"><a href="#关于数字" class="headerlink" title="关于数字"></a>关于数字</h3><ul><li>标签内允许使用数字，但不能完全由数字组成<ul><li><code>#1984</code> ❌</li><li><code>#1984Date</code> ⭕</li><li><code>#da_1984_te</code> ⭕</li><li><code>#date-1984</code>  ⭕</li></ul></li></ul><br><h3 id="标签的嵌套"><a href="#标签的嵌套" class="headerlink" title="标签的嵌套"></a>标签的嵌套</h3><p>在标签名内，使用 <code>/</code> 斜杠 可以实现标签的嵌套</p><p><strong>格式：</strong></p><ul><li><code>#主标签/子标签1</code></li><li><code>#主标签/子标签2</code></li><li><code>#主标签/子标签3</code></li></ul><p>嵌套标签可以像普通标签一样通过点击来唤起搜索，嵌套标签允许你选择搜索的层次。<strong>例如：</strong></p><ul><li>搜索 <code>#主标签</code> ，即可找到包含任意一个子标签的所有笔记<ul><li>返回的结果会是上述的三个例子</li></ul></li><li>当你在一个主分类下设置了多个子分类，想找到这个主分类包含的所有内容时，该功能会很实用</li></ul><br><h3 id="能被使用的符号"><a href="#能被使用的符号" class="headerlink" title="能被使用的符号"></a>能被使用的符号</h3><p>综上所述，标签内能被使用的符号共有三种</p><ol><li><code>_</code> 下划线</li><li><code>-</code> 连字符</li><li><code>/</code> 斜杠</li></ol><br><h3 id="如何让-不被识别"><a href="#如何让-不被识别" class="headerlink" title="如何让 # 不被识别"></a>如何让 # 不被识别</h3><p>可以使用前面提到的转义符号 <code>\</code> 反斜杠，与上述的 转义标题 类似</p><p><strong>格式：</strong></p><p><code>\#这里的内容不会被识别为标签</code></p><p><strong>效果：</strong></p><p>#这里的内容不会被识别为标签</p><br><h2 id="19-避免标识符的滥用"><a href="#19-避免标识符的滥用" class="headerlink" title="19. 避免标识符的滥用"></a>19. 避免标识符的滥用</h2><p>即使在 <strong>Markdown</strong> 中，也要尽量<strong>避免</strong>标识符的滥用</p><p>比如我的这篇教程，就存在一定程度的滥用</p><ul><li>其实是因为我这篇是教学性质的，不太一样，有些不能避免<ul><li><strong>(好吧，我就是在甩锅)</strong></li></ul></li></ul><p>标识符的本质是突出显示，代表<strong>重点</strong></p><ul><li>一篇笔记里的某段文本，使用<strong>各式各样的</strong>的标识符，会造成<strong>重点不清晰</strong></li></ul><p>有<strong>三种</strong>标识，<strong>慎用</strong>！  </p><ol><li>词中对<strong>单个汉字</strong>的标识<ol><li>卧&#x3D;&#x3D;虎&#x3D;&#x3D;藏&#x3D;&#x3D;龙&#x3D;&#x3D;</li></ol></li><li>短语中对<strong>单个英语单词</strong>的标识<ol><li>get a &#x3D;&#x3D;bang&#x3D;&#x3D; out of</li></ol></li><li>标识符的<strong>多层嵌套</strong><ol><li><strong>我感觉快要&#x3D;&#x3D;原地<code>起飞</code>&#x3D;&#x3D;了</strong></li></ol></li></ol><p><strong>原因：</strong></p><ul><li>词义的割裂</li><li>视觉的混乱</li><li>不利于搜索<ul><li><code>卧==虎==藏==龙==</code> <ul><li>搜 <code>卧虎</code> – 搜不到</li><li>搜 <code>藏龙</code>  – 搜不到</li></ul></li></ul></li></ul><!-- 变量区域 -->]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2024/02/20/Test/"/>
      <url>/2024/02/20/Test/</url>
      
        <content type="html"><![CDATA[<p>Hexo测试文章</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello Hexo!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/02/20/hello-world/"/>
      <url>/2024/02/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
